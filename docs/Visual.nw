\documentclass[12pt]{report}
%alt: 12pt, twocolumn, landscape

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\newif\iffacebook

\finaltrue\verbosefalse\facebooktrue
%\finalfalse\verbosetrue\facebooktrue

%cf also some \newif below

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------
%thx to LP, changed for the better a few things :)
% - factorized types
% - helped identify features
% - helped put together related stuff, for instance htop_entities
%   and the mixed/summary view
% - helped split in macrolevel and microlevel code
% - helped the split of view2.ml in view_mainmap, minimap, ui_search, etc.
% - easier to do search and replace on all files, just do it here :)

%thx to pfff_visual:
% - splitted big files like draw.ml and view.ml because saw they were too
%   big

%history LP-ization:
% - skeleton; a not too bad TOC
% - put all content of files in the Extra section
% - split the files in chunks (for type, helpers, ...), using
%   my emacs macro
% - distribute parts of the file before
% - TODO add figures (hand made)
% - TODO add biblio

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
\hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
\def\backref{{\footnotesize cited page(s)}~}%en: \def\backref{{\footnotesize cited page(s)}~}
\usepackage{multirow}
\usepackage{booktabs} 
\newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
%\usepackage{fullpage}


\input{Config}
\usepackage{latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
%%note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par


%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{latex/Macros}

\newcommand{\pfff}{Pfff\xspace}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\implemtrue
\implemoverviewtrue
\wantrepetitivecodefalse
\allcodefalse

\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
CodeMap
}\\
Google Maps for Source Code\\
{version 0.4}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}
%dup: authors.txt

\maketitle 

%dup: with section Copyright
%\pagebreak
\hrule
\begin{quote}
    Copyright \copyright{}  2010-2012 Facebook \\
    Copyright \copyright{}  2013-2021, 2025 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.3.
\end{quote}
\hrule
%\pagebreak
% if implem is included, then the doc contains the full source code
% so the copyright should be LGPL ?

\iffinal
\begingroup
\hypersetup{colorlinks=true, linkcolor=blue}
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

\begin{verbatim}
(*
 * This file is the basis for a new kind of code visualizer, 
 * with real time zoom on a treemap and partial thumbnails with anamorphic
 * code; A google maps but on code :)
 * 
 * 
 * By playing with colors, size, fonts, and transparency, can show lots
 * of stuff.
 * 
 * There is not a single view that can accomodate all 
 * navigation/code-understanding programmer needs. So we provide multiple
 * features that can display things at different levels:
 *  - minimap, for context and quick navigation
 *  - zoomable/draggable map
 *  - content thumbnails, with anamorphic text for more important entities
 *  - magnifying glass on the zoomable map (=> have then 3 layers of zoom
 *    where can each time see the context)
 *  - clickable map so redraw treemap on focused dir (focus, but no more
 *    context, except in the minimap maybe one day)
 *  - speedbar for view histories
 *    (could also provide thumbnails on view histories :) )
 *  - zoom and mouse-follow
 * 
 * That's lots of features. In a way tools like Powerpoint also provide
 * multiple displays on the same data and with zoomable slides, global
 * view on the set of slides, slides thumnails, etc.
 *
 * maxim of information visualization:
 *  - show the data
 *  - show comparisons
 *)

\end{verbatim}

\begin{verbatim}
can copy also what is inside Treemap.tex.nw
\end{verbatim}

\begin{verbatim}
%integrate visualizer and source code ! separate skill for now
%later: integrate more artifacts. See vision.txt

whole program visualization. To actually see the architecture.
\end{verbatim}

\begin{verbatim}
%It also abstract away like PofFS how you organize your information.
If have one big test file or many small test files for instance,
then it does not matter, you can see all of the information at once
as it was a giant tiling plane.
So poffs is a kind of a precursor to codemap :)
\end{verbatim}

Note that Codemap is not a replacement for Emacs or Vi, but more a
companion that works with Emacs or Vi, a little bit
like the Speedbar Emacs project, except it is using a treemap
instead of a classic hiearchy browser.

%vs emacs ?
%vs eclipse ? 

% follow movment towards tiling, ex: xmonad haskell window manager

\section{Getting started}

\begin{verbatim}
 * ./configure -visual
 * 
 * port install gtk2
 * port install cairo
 * port install freetype
 * port install mysql5-devel
 * 
\end{verbatim}

\section{Copyright}

The source code of \pfff is governed by the following copyright:
<<Facebook copyright>>=
(* Yoann Padioleau
 * 
 * Copyright (C) 2010-2012 Facebook
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation, with the
 * special exception on linking described in file license.txt.
 * 
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file
 * license.txt for more details.
 *)
@ 
%alt: (* Copyright 2009, 2010 Facebook. All Rights Reserved. *)

\section{About this document}

#include "latex/About.nw"

\chapter{Examples of Use}

\begin{verbatim}
put cool scenario of use. cool question and how can get visual answer to
those questions!
\end{verbatim}

\section{Viewing the Linux kernel}

Here are the basics:
As you move the mouse, the blue highlighted areas are the next
level of directories.
Double-clicking zooms in on the blue-highlighted area.
Right-clicking zoom directly to the file under the cursor.
Middle-clicking open the file under the cursor in your
emacs provided you have M-x server-start and have emacsclient 
in your path.


<<[[interface_doc]]>>=
let interface_doc = "
This tool displays a \"code map\" of a software project using
Treemaps. \"Treemaps display hierarchical (tree-structured) data as a
set of nested rectangles. Each branch of the tree is given a 
rectangle, which is then tiled with smaller rectangles representing
sub-branches. A leaf node's rectangle has an area proportional 
to a specified dimension on the data.
\" - http://en.wikipedia.org/wiki/Treemapping:

In our case the dimension is the size of the file.
Moreover each file is colored according to its
\"category\": display code, third party code, etc.
See the legend. We use basic heuristcs based on the
name of the files and directory.

Files and directories are also sorted alphabetically
and partially ordered from top to bottom and left to right. 
So a toplevel 'zzz' subdirectory should be located at the bottom 
right of the screen.

As you move the mouse, the blue highlighted areas are the next
level of directories.

Double-clicking zooms in on the blue-highlighted area.
Right-clicking zoom directly to the file under the cursor.
Middle-clicking open the file under the cursor in your
favourite editor (provided you have M-x server-start
and have emacsclient in your path).

"
@ 


\section{Viewing Pfff itself}

\section{Generic semantic visual feedback}

\begin{verbatim}
% big = use
% green = tested
% purple = bad code

%todo: more scenario/workflow showing cool use of codemaps

%sgrep connection ?

% see semantic info like  takeArgByRef or use of globals or ContainDynCall
%  or TODO dead func, 
\end{verbatim}


\chapter{Implementation Overview}

\begin{verbatim}
% say that model/view/controller
\end{verbatim}

\begin{verbatim}
 * Archi: There are different kinds of "drawings":
 *  - 'paint', which does the heavy and expensive rendering
 *  - 'expose', which assemble the already painted pixmaps/layers and allow
 *    moving parts such as overlay rectangles

 * There are also 'draw' which is called by the 'paint'. 'Paint' creates
 * the cairo context and adjust the scaling if needed and then call
 * 'draw'
 
 * then there are cairo layers.

 * 
 * Assumes the treemap contains the absolute paths to existing files/dirs.

\end{verbatim}

\begin{verbatim}
concepts: 
user vs device
see Cairo/Gtk appendix

macro vs micro level
\end{verbatim}

\begin{verbatim}
Plan for following sections.
Dependencies diagram and Tabular.
 - main
 - treemap
 - semantic info and parser
 - assembling layers
 - gtk/cairo
\end{verbatim}

\chapter{Main}

<<main flags>>=
(* on macOS lion, X11 resizes the window to a smaller size so
 * there is no point in starting with a big screen_size :(
 *)
let screen_size = ref 1
let legend = ref false

(* you can also put this in your ~/gtkrc-2.0
 *  gtk-icon-theme-name = "Tango"
 *  gtk-theme-name = "Murrine-Gray"
 *  gtk-font-name = "DejaVu Sans 16"
 * or not put anything and use the default Gtk theme.
 *)

(* if not specified, codemap will try to use files in the current directory *)
let graph_file = ref (None: string (* filename *) option)
let db_file    = ref (None: string (* filename *) option)
let layer_file = ref (None: string (* filename *) option)
let layer_dir  = ref (None: string (* filename *) option)

(* See also Gui.synchronous_actions *)
let test_mode = ref (None: string option)
@

<<function [[main_action]]>>=
let main_action xs = 
  (* this used to be done by linking with gtkInit.cmo, but better like this *)
  let _locale = GtkMain.Main.init () in

  (* TODO: remove, accept just a single root and rely on .codemapignore
   * for advanced customization? or nice to accept multiple so
   * can compare size of different projects together easily?
   * TODO: use Fpath_.common_parent at least
   *)
  let root = Common2_.common_prefix_of_files_or_dirs xs in
  Logs.info (fun m -> m "Using root = %s" root);

  let filter_file = mk_filter_file (Fpath.v root) in

  let async_model = Async.async_make () in

  let layers = 
    match !layer_file, !layer_dir, xs with
    | Some file, _, _ -> 
        [Layer_code.load_layer file]
    | None, Some dir, _ | None, None, [dir] ->
        layers_in_dir dir |> List.map Layer_code.load_layer
    | _ -> []
  in
  let layers_with_index = 
    Layer_code.build_index_of_layers ~root 
      (match !layer_file, layers with 
      | Some _, [layer] -> [layer, true]
      | _ -> layers |> List.map (fun x -> x, false)
      )
  in

  let db_file = 
    match !db_file, xs with
    | Some file, _ -> Some file
    | None, [dir] ->
      let candidates = [
          Filename.concat dir Database_code.default_db_name;
          Filename.concat dir Database_code.default_db_name ^ ".json";
      ] in
      (try 
        Some (candidates |> List.find (fun file -> Sys.file_exists file))
      with Not_found -> None
      )
      | _ -> None
  in
  db_file |> Option.iter (fun db -> 
    Logs.info (fun m -> m "Using pfff light db: %s" db)
  );
  let graph_file : Fpath.t option = 
    match !graph_file, xs with
    | Some file, _ -> Some (Fpath.v file)
    | None, [dir] ->
      let candidates = [
          Filename.concat dir !!Graph_code.default_filename;
      ] in
      (try 
         let file = candidates |> List.find (fun file -> Sys.file_exists file) in
         Some (Fpath.v file)
      with Not_found -> None
      )
    | _ -> None
  in
  graph_file |> Option.iter (fun db -> 
    Logs.info (fun m -> m "Using graphcode: %s" !!db)
  );

  let treemap_func = treemap_generator ~filter_file in
  let dw = Model.init_drawing  treemap_func layers_with_index xs root in

  (* This can require lots of stack. Make sure to have ulimit -s 40000 *)
  Thread.create (fun () ->
    (* heavy computation are not *fairly* scheduled apparently by the OCaml
     * runtime, so let's do the heavy computation in another process
     * and here just have the thread waiting for it to be done.
     * This thread used to cause some Bus error on MacOS but now that
     * we use invoke and do the job in another process things seem better :)
     *)
    let job () = build_model root db_file graph_file in
    let res = Parallel.invoke job () () in
    Async.async_set res async_model;
  ) ()
  |> ignore;
 
  let w = { Model.
    dw;
    dw_stack = ref [dw];
    model = async_model;
    treemap_func;
    current_node = None;
    current_node_selected = None;
    current_entity = None;
    settings = { Model.
      (* todo: too fuzzy for now *)
      draw_summary = false;
      draw_searched_rectangles = true;
    };
    root_orig = root;
  }
  in

  View.mk_gui  ~screen_size:!screen_size ~legend:!legend !test_mode w
@

\chapter{The Model}

\section{The code database}

<<type model>>=
(* filename below should be in readable path format *)
type model = {
  (* for translating the absolute filenames in tr_label in readable so
   * one can access the node in the model for a tr_rectangle 
   *)
  root: string; 

  db: Database_code.database option;
  <<model fields hook>>

  (* for microlevel use/def information *)
  g: Graph_code.t option;
  (* for macrolevel use/def information, only for Dir and File *)
  hfile_deps_of_node: (Graph_code.node, string (* filename *) deps) Hashtbl.t;
  (* we used to store line information there, but the file may have changed *)
  hentities_of_file: (string (* filename *), Graph_code.node list) Hashtbl.t;
 }
@

<<function [[build_model]]>>=
(* this is currently called in the background *)
let build_model root dbfile_opt graphfile_opt =   

  let db_opt = dbfile_opt |> Option.map Database_code.load_database in
  let caps = Cap.readdir_UNSAFE() in
  (* TODO: use List_files *)
  let files = 
    UFile.Legacy.files_of_dirs_or_files_no_vcs_nofilter caps [root] 
    |> List.filter (fun file -> !filter (Fpath.v file))
  in
  let hentities = Model_database_code.hentities root db_opt in
  let all_entities = Model_database_code.all_entities ~root files db_opt in
  let big_grep_idx = Completion.build_completion_defs_index all_entities in

  let g_opt = graphfile_opt |> Option.map Graph_code.load in
  let hfile_deps_of_node, hentities_of_file =
    match g_opt with
    | None -> Hashtbl.create 0, Hashtbl.create 0
    | Some g ->
      let a = Model_graph_code.build_filedeps_of_dir_or_file g in
      let b = Model_graph_code.build_entities_of_file g in
      let b = Model_graph_code.add_headers_files_entities_of_file root b in
      a, Hashtbl_.hash_of_list b
  in
  
  let model = { Model.
        root = root;
        db = db_opt;
        hentities; big_grep_idx;
        g =  g_opt;
        hfile_deps_of_node; hentities_of_file;
  }
  in
  model
[@@profiling]
@ 


\section{The treemap generator}

<<[[treemap_generator]]>>=
(* this is called each time we go in a new directory (or set of dirs) *)
let treemap_generator ~filter_file = 
 fun paths ->
  let treemap = Treemap_pl.code_treemap ~filter_file paths in
  let algo = Treemap.Ordered Treemap.PivotByMiddle in
  let big_borders = !Flag.boost_label_size in
  let rects = Treemap.render_treemap ~algo ~big_borders treemap in
  Logs.debug (fun m -> m "%d rectangles to draw" (List.length rects));
  rects
@ 

\section{The final model}

<<type drawing>>=
(* All the 'float' below are to be intepreted as user coordinates except when
 * explicitely mentioned. All the 'int' are usually device coordinates.
 *)
type drawing = {

  (* Macrolevel. In user coordinates from 0 to T.xy_ratio for 'x' and 0 to 1
   * for 'y'. Assumes the treemap contains absolute paths (tr.tr_label).
   *)
  treemap: Treemap.treemap_rendering;
  (* Microlevel. When we render content at the microlevel, we then need to
   * know to which line corresponds a position and vice versa.
   *)
  microlevel: (Treemap.treemap_rectangle, microlevel) Hashtbl.t;

  (* generated from dw.treemap, contains readable path relative to model.root *)
  readable_file_to_rect: 
    (string (* filename *), Treemap.treemap_rectangle) Hashtbl.t;
  (* coupling: = List.length treemap *)
  nb_rects: int; 
  (* Used to display readable paths. When fully zoomed it's a filename. *)
  current_root: string;

  mutable layers: Layer_code.layers_with_index;

  <<fields drawing query stuff>>

  <<fields drawing main view>>

  <<fields drawing viewport>>

  <<fields drawing minimap>>
}
  <<type settings>>
@

\section{The microlevel specific model}

<<type context>>=
(* a slice of drawing used in the drawing functions *)
type context = {
  model2: model Async.t;
  nb_rects_on_screen: int;
  grep_query: (string (* filename *), line) Hashtbl.t;
  layers_microlevel: 
   (string (* filename *), (int, Simple_color.emacs_color) Hashtbl.t) Hashtbl.t;
}
@ 

\section{On filenames}

\begin{verbatim}
quite tricky. Also had pbs with our testing code. Relative path
are convenient but bad in code. 

- relative
- absolute
- readable

need readable in files so can reuse (for code light database and layers,
see section X and Y later)
\end{verbatim}

<<[[readable_to_absolute_filename_under_root]] sig>>=
val readable_to_absolute_filename_under_root :
  root:string (* filename *) -> string -> string
@

<<[[actual_root_of_db]] sig>>=
val actual_root_of_db : 
  root:string (* filename *) -> Database_code.database -> string
@


<<[[readable_to_absolute_filename_under_root]]>>=
(* People may run the visualizer on a subdir of what is mentionned in the
 * database code (e.g. subdir ~/www/flib of ~/www). The light_db
 * contains only readable paths (e.g. flib/foo.php); the reason for
 * those readable paths is that we want to reuse the light_db
 * and share it among multiple users which may have
 * different paths for their own software repo (e.g. ~/www4/).
 * 
 * When the user select an entity through the search box,
 * we will know the readable paths of the entity he is looking for
 * but we need a full path for refreshing the treemap.
 * We can not just concatenate the root with the readable paths which
 * in the example would lead to the path  ~/www/flib/flib/foo.php.
 * 
 * The goal of the function below is given a readable path like
 * flib/foo.php and a root like ~/www/flib  to recognize the common part
 * and return a valid fullpath like ~/www/flib/foo.php
 * 
 *)
let readable_to_absolute_filename_under_root ~root filename =

  (* the root may be a filename *)
  let root_dir = 
    if UFile.is_dir ~follow_symlinks:false (Fpath.v root) then root
    else Filename.dirname root
  in

  let root_and_parents =
    Common2_.inits_of_absolute_dir root_dir |> List.rev
  in
  try 
    root_and_parents |> Common2_.return_when (fun dir ->
      let path = Filename.concat dir filename in
      if Sys.file_exists path
      then Some path
      else None
    )
  with Not_found ->
    failwith 
      (spf "can't find file %s with root = %s" filename root)
@


<<[[actual_root_of_db]]>>=
let actual_root_of_db ~root db =
  let a_file = (db.Db.entities.(0)).Db.e_file in
  let absolute_file = 
    readable_to_absolute_filename_under_root root a_file in
  
  if absolute_file =~ ("\\(.*\\)/" ^ a_file)
  then Common.matched1 absolute_file
  else failwith (spf "Could not find actual_root of %s under %s: "
                    absolute_file root)
@


\section{Misc}

<<hentities sig>>=
val hentities :
  string (* filename *) -> Database_code.database option -> 
  (string, Database_code.entity) Hashtbl.t
@
<<model fields hook>>=
(* fast accessors *)
hentities : (string (* short name *), Database_code.entity) Hashtbl.t;
@ 



<<hentities()>>=
(* We want to display very often used functions in bigger size font.
 * Enter database_code.ml which provides a language-independent database of
 * information on source code.
 * 
 * We compute the entities outside init_drawing because
 * init_drawing can be called multiple times (when we zoom in)
 * and we dont want the heavy entities computation to be 
 * repeated.
 *)
let hentities root db_opt = 
  let hentities = Hashtbl.create 1001 in

  db_opt |> Option.iter (fun db ->

    let actual_root = actual_root_of_db ~root db in

      (* todo sanity check that db talks about files
       * in dirs_or_files ? Ensure same readable path.
       *)
      db.Db.entities |> Array.iter (fun e ->
        Hashtbl.add hentities
          e.Db.e_name
          {e with Db.e_file = 
              Filename.concat actual_root e.Db.e_file
          }
      );
  );
  hentities
@



<<[[init_drawing]] sig>>=
val init_drawing :
  ?width:int ->
  ?height:int ->
  (string (* filename *) list -> Treemap.treemap_rendering) ->
  Layer_code.layers_with_index ->
  string (* filename *) list -> 
  string (* root *) ->
  drawing
@

<<[[init_drawing]]()>>=
(* This is a first guess. The first configure ev will force a resize. *)
let init_drawing   ?(width = 600) ?(height = 600) func layers paths root =
  let paths = List.map Common2_.relative_to_absolute paths in
  let current_root = Common2_.common_prefix_of_files_or_dirs paths in
  let treemap = 
    Profiling.profile_code "Visual.building the treemap" (fun () -> 
      func paths
    ) 
  in
  let readable_file_to_rect =
    treemap |> List_.filter_map (fun rect ->
      if not rect.T.tr_is_node
      then 
        let file  = rect.T.tr_label in
        let readable = (Filename_.readable ~root:(root) (file)) in
        Some (readable, rect)
      else None
    ) |> Hashtbl_.hash_of_list
  in
  {
    treemap;
    nb_rects = List.length treemap;
    current_root;
    readable_file_to_rect;
    microlevel = Hashtbl.create 0;
    layers;
    current_query = "";
    current_searched_rectangles = [];
    current_grep_query = Hashtbl.create 0;
    width; height;
    base    = new_surface ~alpha:false ~width ~height;
    overlay = new_surface ~alpha:true ~width ~height;
  }
@

\chapter{The UI}

\section{Overall organisation}

\begin{verbatim}
 * Overall UI organisation:
 *  - menu
 *  - toolbar
 *  - mainview (treemap | minimap/legend)
 *  - statusbar 
 * 
 * Conventions and info: see commons/gui.ml
\end{verbatim}

<<[[mk_gui]] sig>>=
val mk_gui :
  screen_size:int -> legend:bool -> 'b option (* test *) -> Model.world ->
  unit
@ 


<<view globals>>=
(* when some widgets need to access other widgets *)

(* Note that because we use toplevels 'let' for the GUI elements below,
 * Gtk must have also been initialized via a toplevel element, or
 * initialized by including gtkInit.cmo earlier in the linking command.
 *)

@ 

\section{Menu}

\section{Toolbar}

\section{Main view}

\section{Status bar}

\section{Misc}

<<[[mk_gui]]()>>=
let mk_gui ~screen_size ~legend test_mode w =
  let width, height, minimap_hpos, minimap_vpos = 
    Style.windows_params screen_size in
  (* bugfix: can not set xy_ratio here because it's too late. We already
   * computed the treemap with the old xy_ratio and changing xy_ratio now
   * leads to the right part of the treemap to not be visible
   * todo: why??
  Treemap.xy_ratio := (float_of_int width) /. (float_of_int height);
  pr2 (spf "using %f for xy_ratio" !Treemap.xy_ratio);
   *)

  let win = GWindow.window 
    ~title:(Controller.title_of_path w.dw.current_root)
    ~width ~height
    ~allow_shrink: true
    ~allow_grow:true
    () 
  in
  Controller._set_title := (fun s -> win#set_title s);

  let statusbar = GMisc.statusbar () in
  let ctx = statusbar#new_context "main" in
  Controller._statusbar_addtext := (fun s -> ctx#push s |> ignore);

  let accel_group = GtkData.AccelGroup.create () in
  win#misc#set_name "main window";

  let quit () = 
    (*Controller.before_quit_all model;*)
    GMain.Main.quit ();
  in

  win#add_accel_group accel_group;

  (*-------------------------------------------------------------------*)
  (* Layout *)
  (*-------------------------------------------------------------------*)

  (* if use my G.mk style for that, then get some pbs when trying
   * to draw stuff :(
   *)
  let vbox = GPack.vbox ~packing:win#add () in
  let hbox = GPack.hbox ~packing:(vbox#pack ~expand:false ~fill:false) () in

    (*-------------------------------------------------------------------*)
    (* Menu *)
    (*-------------------------------------------------------------------*)
    hbox#pack (G.mk (GMenu.menu_bar) (fun m -> 
      let factory = new GMenu.factory m in

      factory#add_submenu "_Move" |> (fun menu -> 
        let fc = new GMenu.factory menu ~accel_group in

        fc#add_item "_Go back" ~key:K._B ~callback:(fun () -> 
          !Controller._go_back w;
        ) |> ignore;

        fc#add_item "_Go to example" ~key:K._E ~callback:(fun () -> 
          let model = Async.async_get w.model in
          match w.current_entity, model.db with
          | Some e, Some db ->
              (match e.Db.e_good_examples_of_use with
              | [] -> failwith "no good examples of use for this entity"
              | x::_xs ->
                  let e = db.Db.entities.(x) in
                  let file = e.Db.e_file in

                  let final_file = 
                    Model_database_code.readable_to_absolute_filename_under_root
                      file ~root:w.dw.current_root in
                  w.current_entity <- Some e;
                  !Controller._go_dirs_or_file w [final_file];
              )
          | _ -> failwith "no entity currently selected or no db"
        ) |> ignore;
        fc#add_item "_Quit" ~key:K._Q ~callback:quit |> ignore;
      );

      factory#add_submenu "_Search" |> (fun menu -> 
        let fc = new GMenu.factory menu ~accel_group in

        fc#add_item "_Git grep" ~key:K._G ~callback:(fun () -> 

          let res = Ui_search.dialog_search_def w.model in
          res |> Option.iter (fun s ->
            let root = w.root_orig in
            let matching_files = Ui_search.run_grep_query ~root s in
            let files = matching_files |> List.map fst |> Common2.uniq in
            let current_grep_query = 
              Some (Hashtbl_.hash_of_list matching_files)
            in
            !Controller._go_dirs_or_file ~current_grep_query w files
          );
        ) |> ignore;

        fc#add_item "_Tbgs query" ~key:K._T ~callback:(fun () -> 

          let res = Ui_search.dialog_search_def w.model in
          res |> Option.iter (fun s ->
            let root = w.dw.current_root in
            let matching_files = Ui_search.run_tbgs_query ~root s in
            let files = matching_files |> List.map fst |> Common2.uniq in
            let current_grep_query = 
              Some (Hashtbl_.hash_of_list matching_files)
            in
            !Controller._go_dirs_or_file ~current_grep_query w files
          );
        ) |> ignore;

      );
      factory#add_submenu "_Layers" |> (fun menu -> 
        let layers = 
          w.dw.layers.Layer_code.layers |> List.map (fun (layer, active) ->
            (layer.Layer_code.title, active, (fun b -> 
              if b then
                Ui_layers.choose_layer ~root:w.root_orig
                  (Some layer.Layer_code.title) w;
            ))
          )
        in
        (* todo: again, make the architecture a layer so less special cases *)
        let entries = [`R (
             ("Architecture", true, (fun _b ->
               Ui_layers.choose_layer ~root:w.root_orig None w;
             ))::
             layers)
        ]
        in
        GToolbox.build_menu menu ~entries
      );

      factory#add_submenu "_Misc" |> (fun menu -> 
        let fc = new GMenu.factory menu ~accel_group in

        fc#add_item "_Refresh" ~key:K._R ~callback:(fun () -> 
          let current_root = w.dw.current_root in
          let _old_dw = Stack_.pop w.dw_stack in
          !Controller._go_dirs_or_file w [current_root];
        ) |> ignore;

        fc#add_item "Reset entity" ~callback:(fun () ->
          w.current_node_selected <- None;
          let cr_overlay = Cairo.create w.dw.overlay in
          CairoH.clear cr_overlay;
          !Controller._refresh_da();
        ) |> ignore;
      );

      factory#add_submenu "_Help" |> (fun menu -> 
        let fc = new GMenu.factory menu ~accel_group in

        fc#add_item "_Interface" ~key:K._H ~callback:(fun () -> 
            G.dialog_text Help.interface_doc "Help"
        ) |> ignore;

        fc#add_item "_Legend" ~key:K._L ~callback:(fun () -> 
          raise Todo
        ) |> ignore;

        fc#add_item "_Help on Pfff" ~callback:(fun () -> 
            G.dialog_text "Read\nthe\nsource\n\ndude" "Help" |> ignore;
        ) |> ignore;
        fc#add_separator () |> ignore;
        fc#add_item "About" ~callback:(fun () -> 
            G.dialog_text "Brought to you by pad\nwith love" "About"
        ) |> ignore;
      );
    ));

    (*-------------------------------------------------------------------*)
    (* toolbar *)
    (*-------------------------------------------------------------------*)
    hbox#pack ~padding:10 (G.mk (GButton.toolbar) (fun tb ->

      let idx = (fun () -> 
        let model : Model.model = Async.async_get w.model in
        model.big_grep_idx 
      )
      in

      let entry = 
        Completion.my_entry_completion_eff 
         ~callback_selected:(fun entry str _file e ->
          (* pb is that we may have run the visualizer on a subdir
           * of what is mentionned in the database code. We have
           * then to find the real root.
           *)
          entry#set_text "";

          let readable_paths = 
            (* hack to handle multidirs *)
            match e.Db.e_kind with
            | Entity_code.MultiDirs ->
                (* hack: coupling: with mk_multi_dirs_entity *)
                String_.split ~sep:"|" e.Db.e_file
            | _ ->
                [e.Db.e_file]
          in

          let final_paths = 
            readable_paths |> List.map 
              (Model_database_code.readable_to_absolute_filename_under_root 
                 ~root:w.dw.current_root)
          in

          Log.debug (fun m -> m "e= %s, final_paths= %s" str(String.concat "|" final_paths));
          w.current_entity <- Some e;
          Async.async_get_opt w.model |> Option.iter (fun model ->
            model.g |> Option.iter (fun g ->
              w.current_node_selected <- 
                Model_graph_code.node_of_entity e g
            )
          );
          !Controller._go_dirs_or_file w final_paths;
          true
        )
        ~callback_changed:(fun str ->
          w.dw.current_query <- str;
          w.dw.current_searched_rectangles <- [];

          if w.settings.draw_searched_rectangles
          then begin
            (* better to compute once the set of matching rectangles
             * cos doing it each time in motify would incur too much
             * calls to ==~
             *)
            let minimum_length = 3 in

            if String.length str > minimum_length then begin

              let rects = w.dw.treemap in
              let re_opt = 
                try Some (Str.regexp (".*" ^ str))
               (* can raise exn when have bad or not yet complete regexp *)
                with _ -> None
              in
              let res = 
                match re_opt with
                | None -> []
                | Some re ->
                    rects |> List.filter (fun r -> 
                      let label = r.T.tr_label |> String.lowercase_ascii in
                      label ==~ re
                    )
              in
              w.dw.current_searched_rectangles <- res;
              
            end;
            let cr_overlay = Cairo.create w.dw.overlay in
            CairoH.clear cr_overlay;
            View_overlays.draw_searched_rectangles ~dw:w.dw;
            !Controller._refresh_da();
          end
        )
        idx
      in

      tb#insert_widget (G.with_label "Search:" entry#coerce);

      tb#insert_widget (G.mk (GButton.button ~stock:`GO_BACK) (fun b -> 
        b#connect#clicked ~callback:(fun () -> 
          !Controller._go_back w;
        ) |> ignore;
      ));

      tb#insert_widget (G.mk (GButton.button ~stock:`GO_UP) (fun b -> 
        b#connect#clicked ~callback:(fun () -> 
          let current_root = w.dw.current_root in
          !Controller._go_dirs_or_file w [Filename.dirname current_root];
        ) |> ignore;
      ));

      tb#insert_widget (G.mk (GButton.button ~stock:`GOTO_TOP) (fun b -> 
        b#connect#clicked ~callback:(fun () -> 
          let top = Common2.list_last !(w.dw_stack) in
          (* put 2 in the stack because _go_back will popup one *)
          w.dw_stack := [top; top];
          !Controller._go_back w;
        ) |> ignore;
      ));
    ));

    (*-------------------------------------------------------------------*)
    (* main view *)
    (*-------------------------------------------------------------------*)

    let hpane = GPack.paned `HORIZONTAL
      ~packing:(vbox#pack ~expand:true ~fill:true) () in

    let da = GMisc.drawing_area () in
    da#misc#set_double_buffered false;
    hpane#add1 da#coerce;

   
    let vpane = GPack.paned `VERTICAL () in
    hpane#set_position minimap_hpos;

    let da3 = GMisc.drawing_area () in
    vpane#set_position minimap_vpos;
    vpane#add2 da3#coerce;


    if legend then hpane#add2 vpane#coerce;

    da#misc#set_can_focus true ;
    da#event#add [ `KEY_PRESS;
                   `BUTTON_MOTION; `POINTER_MOTION;
                   `BUTTON_PRESS; `BUTTON_RELEASE ];

    (* subtle: do not change those callbacks to get a dw; you need to
     * pass a w! Indee if you do ~callback:(expose da w.dw)
     * and an event changes w.dw (e.g. a resize of the window)
     * then the expose event will still expose the old drawing.
     *)
    da#event#connect#expose ~callback:(expose da w) |> ignore;
    da#event#connect#configure ~callback:(configure w) |> ignore;
    da3#event#connect#expose ~callback:(expose_legend da3 w) |> ignore;

    da#event#connect#button_press 
      (View_mainmap.button_action w) |> ignore;
    da#event#connect#button_release 
      (View_mainmap.button_action w) |> ignore;
    da#event#connect#motion_notify  
      (View_overlays.motion_notify w) |> ignore; 

    Controller._refresh_da := (fun () ->
      GtkBase.Widget.queue_draw da#as_widget;
    );
    Controller._refresh_legend := (fun () ->
      GtkBase.Widget.queue_draw da3#as_widget;
    );
    Controller._go_back := Ui_navigation.go_back;
    Controller._go_dirs_or_file := Ui_navigation.go_dirs_or_file;
    Controller.hook_finish_paint := (fun () ->
      View_overlays.hook_finish_paint w
    );
      
    (*-------------------------------------------------------------------*)
    (* status bar *)
    (*-------------------------------------------------------------------*)
    (* the statusbar widget is defined in beginning of this file because *)
    vbox#pack (*~from: `END*) statusbar#coerce;

  (*  )); *)

  (*-------------------------------------------------------------------*)
  (* End *)
  (*-------------------------------------------------------------------*)

  (* Controller._before_quit_all_func |> Common.push2 Model.close_model; *)

  GtkSignal.user_handler := (fun exn -> 
    Log.debug (fun m -> m "fucking callback");
    (* old: before 3.11: Features.Backtrace.print(); *)
    let s = Printexc.get_backtrace () in
    Log.debug (fun m-> m "%s" s);
    let pb = "pb: " ^ Common.exn_to_s exn ^ "\n" ^ s in
    G.dialog_text ~text:pb ~title:"pb";
    raise exn
  );

  (* TODO: should do that on 'da', not 'w' 
  w#event#connect#key_press ~callback:(key_pressed (da,da2) dw) |> ignore;
  *)

(*
  w#event#connect#key_press ~callback:(fun ev -> 
    let k = GdkEvent.Key.keyval ev in
    (match k with
    | _ when k = Char.code 'q' -> 
        quit();
        true   
    | _ -> false
    )
  );
*)

  win#event#connect#delete    ~callback:(fun _  -> quit(); true) |> ignore;
  win#connect#destroy         ~callback:(fun () -> quit(); ) |> ignore;
  win#show ();

  (* test *)
  test_mode |> Option.iter (fun _s -> 
    (* View_test.do_command s model *)
    ()
  );
  (* Gui.gmain_idle_add ~prio: 1000 (idle dw) |> ignore; *)
  GtkThread.main ();
  ()
@

\chapter{The Controller}

\chapter{Macrolevel View: The Treemap}

%macro-level visualization. See also archi_code.ml.

\section{Principles}

% xyratio

\section{Drawing}

% \label{user-vs-device}

<<[[device_to_user_area]]>>=
(* still needed ? reuse helper functions above ? *)
let device_to_user_area dw = 
  with_map dw (fun cr ->

    let user_point1 = Cairo.device_to_user cr 
      0. 0. in
    let user_point2 = Cairo.device_to_user cr 
      (float_of_int dw.width) (float_of_int dw.height) in
    
    { F.p = CairoH.cairo_point_to_point user_point1;
      F.q = CairoH.cairo_point_to_point user_point2;
    }
  )
@ 


<<[[draw_treemap_rectangle]] sig>>=
val draw_treemap_rectangle :
  cr:Cairo.context -> 
  ?color:Simple_color.emacs_color option -> 
  ?alpha:float -> 
  Treemap.treemap_rectangle -> 
  unit
@ 

<<[[draw_treemap_rectangle]]()>>=
let draw_treemap_rectangle2 ~cr ?(color=None) ?(alpha=1.) rect =
  let r = rect.T.tr_rect in

  (let (r,g,b) = 
    let (r,g,b) = rect.T.tr_color |> Color.rgb_of_color |> Color.rgbf_of_rgb in
    match color with
    | None -> (r,g,b)
    | Some c -> 
        let (r2,g2,b2) = c |> Color.rgbf_of_string in
        (r2 + r / 20., g2 + g / 20., b2 + b / 20.)
  in
  Cairo.set_source_rgba cr r g b (alpha);
  );

  Cairo.move_to cr r.p.x r.p.y;
  Cairo.line_to cr r.q.x r.p.y;
  Cairo.line_to cr r.q.x r.q.y;
  Cairo.line_to cr r.p.x r.q.y;

  Cairo.fill cr;
  ()

let draw_treemap_rectangle ~cr ?color ?alpha a =
  Profiling.profile_code "View.draw_treemap_rectangle" (fun () -> 
    draw_treemap_rectangle2 ~cr ?color ?alpha a)
@ 


\section{Labels}

<<[[draw_treemap_rectangle_label_maybe]] sig>>=
val draw_treemap_rectangle_label_maybe :
  cr:Cairo.context -> 
  zoom:float -> 
  color:Simple_color.emacs_color option -> 
  Treemap.treemap_rectangle -> 
  unit
@ 


<<[[draw_treemap_rectangle_label_maybe]]>>=
let _hmemo_text_extent = Hashtbl.create 101

(* This can be quite cpu intensive. CairoH.text_extents is quite slow
 * so you must avoid calling it too much. A simple optimisation
 * when the treemap is big is to avoid trying to draw labels
 * that are too tiny already.
 * 
 * note that this function is also called when we mouse over a rectangle
 * in which case we redraw the label in a different color
 * 
 * design: good to have a color different for dir and files.
 * 
 * design: could decide to give different colors to dirs depending on its
 * depth, like red for toplevel dir, green, and so on, like I do for 
 * my code sections, but feel simpler to just have one.
 * The rectangles will already have different colors and in the end
 * the depth does not have that much meaning in projects. For instance
 * in java code there are lots of nested directories (org/apache/...),
 * in some projects there is always an intermediate src/ directory;
 * each software have different conventions.
 *)
let rec draw_treemap_rectangle_label_maybe2 ~cr ~zoom ?(color=None) rect =
  if !Flag.disable_fonts then ()
  else begin

  let lbl = rect.T.tr_label in
  let base = Filename.basename lbl in
  (* old: Common.is_directory_eff lbl *)
  let is_directory = rect.T.tr_is_node in

  let txt = 
    if is_directory
    then base ^ "/"
    else base
  in
  let color = 
    match color with
    | None -> 
        if is_directory 
        then "NavyBlue"
        else "black"
    | Some c -> c
  in

  Cairo.select_font_face cr "serif" ~weight:Cairo.Bold;

  let font_size, minus_alpha = 
    if not !Flag.boost_label_size
    then 
     (match rect.T.tr_depth with
    | 1 -> 0.1, 0.8
    | 2 -> 0.05, 0.2
    | 3 -> 0.03, 0.4
    | 4 -> 0.02, 0.5
    | 5 -> 0.02, 0.65
    | 6 -> 0.02, 0.7
    | _ -> 0.02, 0.8
     )
    else
    (match rect.T.tr_depth with
    | 1 -> 0.1, 0.8
    | 2 -> 0.06, 0.2
    | 3 -> 0.045, 0.3
    | 4 -> 0.041, 0.35
    | 5 -> 0.04, 0.4
    | 6 -> 0.03, 0.45
    | _ -> 0.02, 0.5
    )
  in
  let font_size = font_size / (zoom) (* use zoom factor inversely *) in
  let alpha = 1. - (minus_alpha / zoom) in

  try_draw_label 
    ~font_size_orig:font_size
    ~color ~alpha 
    ~cr ~rect txt
  end


and try_draw_label ~font_size_orig ~color ~alpha ~cr ~rect txt =

(* ugly: sometimes labels are too big. Should provide a way to
 * shorten them.
 * let txt = 
 * if true
 * then if txt =~ "org.eclipse.\\(.*\\)" then Common.matched1 txt else txt
 * else txt
 * in
 *)
(*
  let txt = 
  if true
  then if txt =~ "[^-]*-\\(.*\\)" then Common.matched1 txt else txt
  else txt
  in
*)
  let r = rect.T.tr_rect in
  
  let w = F.rect_width r in
  let h = F.rect_height r in

  let is_file = 
    (* old: try Common.is_file_eff rect.T.tr_label with _ -> false *)
    not rect.T.tr_is_node
  in

  (let (r,g,b) = color |> Color.rgbf_of_string in
   Cairo.set_source_rgba cr r g b alpha;
  );

  let rec aux ~font_size ~step =

    (* opti: this avoid lots of computation *)
    let font_size_real = CairoH.user_to_device_font_size cr font_size in

    if font_size_real < !Flag.threshold_draw_label_font_size_real
    then ()
    else begin

     CairoH.set_font_size cr font_size;

     (* opti:
      *  was let extent = CairoH.text_extents cr txt
      *)
     let th, base_tw = 
       Common.memoized _hmemo_text_extent (font_size, font_size_real) (fun ()->
         (* peh because it exercises the spectrum of high letters *)
         let extent = CairoH.text_extents cr "peh" in
         let tw = extent.Cairo.width in
         let th = extent.Cairo.height in
         th, tw
       )
     in
     let tw = float_of_int (String.length txt) * base_tw / 3. in
           
     
     (* will try first horizontally at a certain size, then
      * diagonally at a certain size, and if can't then reduce
      * the font_size (up to a certain limit) and try again
      * (first horizontally, then diagonally).
      *)
     match step with
     | 1 | 4 | 7 | 10 when tw < w && th < h && rect.T.tr_depth > 1 ->
           (* see http://cairographics.org/tutorial/#L3showtext 
            * for the logic behind the placement of the text
            *)
     
           let x = r.p.x + w / 2.0 - (tw / 2.0) in
           let y = r.p.y + h / 2.0 + (th / 2.0) in
       
           Cairo.move_to cr x y;
           CairoH.show_text cr txt;

           (* '<= 2' actually means "the toplevel entries" as 
            * the root is at depth=1
            *)
           if rect.T.tr_depth <= 2 then begin
             (let (r,g,b) = Color.rgbf_of_string "red" in
              Cairo.set_source_rgba cr r g b alpha;
             );
             Cairo.move_to cr x y;
             CairoH.show_text cr (String.sub txt 0 1);
           end
           
   
     | 2 | 5 | 8 | 11 when 
           tw < sqrt (w * w + h * h) && 
           th < min w h &&
             rect.T.tr_depth > 1 ->
           (* todo: try vertically ... *)
   
         (* you have to draw on a paper to understand this code below ... *)
   
         let tangent = h / w in
         let angle = atan tangent in
   
         (* right now we don't handle the fact that the text itself has
          * a height but below the x and y positions are just the
          * place of the very bottom of the first letter. In some way we trace a
          * line below the text in the diagonal of the rectangle. This means all
          * the text is on the top of the diagonal. It should be in the middle
          * of the diagonal. 
          * As a first fix we can artificially augment the angle ... ugly
          *)
         let angle = 
           min (angle + angle / 10.) (Math.pi / 2.) 
         in
   
         (* I love basic math *)
         let x = r.p.x + w / 2.0 - (cos angle * (tw / 2.0)) in
         let y = r.p.y + h / 2.0 - (sin angle * (tw / 2.0)) in
         Cairo.move_to cr x y;
   
           
         Cairo.rotate cr angle;
         CairoH.show_text cr txt;
         Cairo.rotate cr (-. angle);
         
         if rect.T.tr_depth <= 2 then begin
           (let (r,g,b) = Color.rgbf_of_string "red" in
            Cairo.set_source_rgba cr r g b alpha;
           );
           Cairo.move_to cr x y;
           Cairo.rotate cr angle;
           CairoH.show_text cr (String.sub txt 0 1);
           Cairo.rotate cr (-. angle);
         end;



   
     | 3 ->
         (* I am ok to go down to 70% *)
         let font_size = font_size_orig * 0.7 in
         aux ~step:4 ~font_size
     | 6 ->
         (* I am ok to go down to 50% of original *)
         let font_size = font_size_orig * 0.5 in
         aux ~step:7 ~font_size
   
     | 9 ->
         (* I am ok to go down to 30% of original for file only  *)
         if is_file
         then 
           let font_size = font_size_orig * 0.25 in
           aux ~step:10 ~font_size
         else ()
   
     (* this case is taken only for the first cases (1, 2, ..) when the
      * associated 'when' expression is false
      *)
     | n -> 
         if n >= 12
         then ()
         else aux ~step:(n +.. 1) ~font_size
    end
  in
  aux ~font_size:font_size_orig ~step:1 

let draw_treemap_rectangle_label_maybe ~cr ~zoom ~color rect =
  Profiling.profile_code "View.draw_label_maybe" (fun () ->
    draw_treemap_rectangle_label_maybe2 ~cr ~zoom ~color rect)
@ 


\section{Color code}

\begin{verbatim}
This is kind of interfile "aspect"
\end{verbatim}

<<[[paint_legend]]>>=
(* todo: make the architecture a layer so no need for special case *)
let draw_legend ~cr =

  let archis = Archi_code.source_archi_list in
  let grouped_archis = archis |> Assoc.group_by_mapped_key (fun archi ->
    (* I tend to favor the darker variant of the color in treemap_pl.ml hence
     * the 3 below
     *)
    Treemap_pl.color_of_source_archi archi ^ "3"
  )
  in
  let grouped_archis = grouped_archis |> List.map (fun (color, kinds) ->
    color, kinds |> List.map Archi_code.s_of_source_archi |> String.concat ", "
  ) in
  draw_legend_of_color_string_pairs ~cr grouped_archis

@ 

<<[[expose_legend]]>>=
let expose_legend da w _ev = 
  let dw = w.dw in
  let cr = Cairo_gtk.create da#misc#window in

  (* todo: make the architecture a layer so no need for special case *)
  (if not (Layer_code.has_active_layers dw.layers)
  then Draw_legend.draw_legend ~cr
  else Draw_legend.draw_legend_layer ~cr dw.layers
  );
  true
@ 



\chapter{Microlevel View: Source Thumbnails}

% micro-level visualization. See also highlight_code.ml

\section{Principles}

\section{Drawing}

<<type [[draw_content_layout]]>>=
@ 


<<[[draw_treemap_rectangle_content_maybe]] sig>>=
(* will render (maybe) the file content of treemap_rectangle.tr_label *)
val draw_treemap_rectangle_content_maybe:
  Cairo.context ->
  Figures.rectangle ->
  Model.context ->
  Treemap.treemap_rectangle -> 
  Model.microlevel option
@ 

\section{Entities size}

<<[[final_font_size_when_multiplier]]>>=
let final_font_size_when_multiplier 
    ~multiplier ~size_font_multiplier_multiplier 
    ~font_size ~font_size_real 
   = 
  ignore(font_size_real);
  let size_font_multiplier = multiplier in
  
  let font_size_adjusted = 
    if size_font_multiplier = 1.
    then font_size
    else 
      max 
       (font_size * size_font_multiplier * size_font_multiplier_multiplier)
       (font_size * 1.5)
  in
  
  let final_font_size = 
    Common2.borne ~min:font_size ~max:(font_size * 30.) font_size_adjusted
  in
  final_font_size
@ 


<<[[final_font_size_of_categ]]>>=
let final_font_size_of_categ ~font_size ~font_size_real categ = 

  let multiplier = Style.size_font_multiplier_of_categ ~font_size_real categ in
  (* as we zoom in, we don't want to be as big, and as we zoom out we want
   * to be bigger
   *)
  let multiplier = 
     (*- 0.2 * font_size_real + 2. *)
    match font_size_real with
    | n when n < 3. -> 2.0 * multiplier
    | n when n < 8. -> 0.8 * multiplier
    | n when n < 10. -> 0.7 * multiplier
    | _ -> 0.5 * multiplier
  in
  Common2_.borne ~min:font_size ~max:(font_size * 30.) (font_size * multiplier)

@ 


\section{Column layout}

<<[[font_size_when_have_x_columns]]>>=
let font_size_when_have_x_columns ~nblines ~chars_per_column ~w ~h ~with_n_columns = 
  let size_x = (w / with_n_columns) / chars_per_column in
  let size_y = (h / (nblines / with_n_columns)) in
  min size_x size_y
@ 


<<[[optimal_nb_columns]]>>=
(* Given a file with nblines and nbcolumns (usually 80) and
 * a rectangle of w width and h height, what is the optimal
 * number of columns. The principle is to start at 1 column
 * and see if by adding columns we can have a bigger font.
 * We try to maximize the font_size.
 *)
let optimal_nb_columns ~nblines ~chars_per_column ~w ~h = 
  
  let rec aux current_font_size current_nb_columns = 
    let min_font = font_size_when_have_x_columns 
      ~nblines ~chars_per_column ~w ~h ~with_n_columns:current_nb_columns
    in
    if min_font > current_font_size
    then aux min_font (current_nb_columns + 1.)
    (* regression, then go back on step *)
    else current_nb_columns - 1.
  in
  aux 0.0 1.0
@


<<[[draw_column_bars]]>>=
let draw_column_bars cr layout r = 
  for i = 1 to int_of_float (layout.split_nb_columns - 1.) do
    let i = float_of_int i in
      
    Cairo.set_source_rgba cr 0.0 0.0 1. 0.2;

    let font_size_real = CairoH.user_to_device_font_size cr layout.lfont_size in
    let width = 
      if font_size_real > 5.
      then layout.lfont_size / 10.
      else layout.lfont_size
    in
    Cairo.set_line_width cr width;

    Cairo.move_to cr (r.p.x + layout.width_per_column * i) r.p.y;
    Cairo.line_to cr (r.p.x + layout.width_per_column * i) r.q.y;
    Cairo.stroke cr ;
  done
[@@profiling]
@ 


\section{Content rendering}

% thumbnails and actual source is same code! not like in visual studio

<<[[draw_content]]>>=
let draw_content cr layout context tr =

  let r = tr.T.tr_rect in
  let file = tr.T.tr_label in

  let font_size = layout.lfont_size in
  let font_size_real = CairoH.user_to_device_font_size cr font_size in

  if font_size_real > Style.threshold_draw_dark_background_font_size_real
  then begin

    (* erase what was done at the macrolevel *)
    if Hashtbl.length context.layers_microlevel > 0 then begin
      Draw_macrolevel.draw_treemap_rectangle ~cr ~color:(Some "white") 
        ~alpha:1.0 tr;
    end;

    let alpha = 
      match context.nb_rects_on_screen with
      | n when n <= 1 -> 0.95
      | n when n <= 2 -> 0.8
      | n when n <= 10 -> 0.6
      | _ -> 0.3
    in
    (* unset when used when debugging the layering display *)
    (* if Hashtbl.length context.layers_microlevel = 0 *)

    Draw_macrolevel.draw_treemap_rectangle ~cr ~color:(Some "DarkSlateGray") 
      ~alpha tr;
    (* draw a thin rectangle with aspect color *)
    CairoH.draw_rectangle_bis ~cr ~color:(tr.T.tr_color) 
      ~line_width:(font_size / 2.) tr.T.tr_rect;
  end;

  (* highlighting layers (and grep-like queries at one point) *)
  let hmatching_lines = 
    try Hashtbl.find context.layers_microlevel file
    with Not_found -> Hashtbl.create 0
  in
  (* todo: make sgrep_query a form of layer *)
  let matching_grep_lines = 
    try Hashtbl.find_all context.grep_query file
    with Not_found -> []
  in
  matching_grep_lines |> List.iter (fun line ->
    let (Line iline) = line in
    Hashtbl.add hmatching_lines (iline+..1) "purple"
  );

  (* the important function call, getting the decorated content *)
  let glyphs_opt = 
    glyphs_of_file ~font_size ~font_size_real context.model2 file in

  glyphs_opt |> Option.iter (fun glyphs ->
    glyphs |> Array.iteri (fun line_0_indexed _glyph ->
      let lc = line_to_line_in_column (Line line_0_indexed) layout in
      let x, y = line_in_column_to_bottom_pos lc r layout in
      Cairo.move_to cr x y;
      
      glyphs.(line_0_indexed) |> List.iter (fun glyph ->
        let (x, y) = Cairo.Path.get_current_point cr in
        glyph.pos <- {Figures.x; y };
        Cairo.set_font_size cr glyph.M.font_size;
        let (r,g,b) = Color.rgbf_of_string glyph.color in
        Cairo.set_source_rgba cr r g b 1.;
        CairoH.show_text cr glyph.M.str;
      );

      (* hmatching_lines comes from layer_microlevel which is 1-index based *)
      let line = line_0_indexed +.. 1 in
      (match Common2_.hfind_option line hmatching_lines with
      | None -> ()
      | Some color ->
        CairoH.fill_rectangle ~cr 
          ~alpha:0.25
          ~color
          ~x 
          (* 'y' is from line_in_column_to_bottom_pos() so it's a bottom pos
           * todo? do we want to show 3 lines centered, hence the * 2 below?
           *)
          ~y:(y - (layout.height_per_line (* * 2. *)) )
          ~w:layout.width_per_column 
          ~h:(layout.height_per_line (* * 3. *))
          ()
      );
    );
  );

  { line_to_rectangle = 
      (fun line -> line_to_rectangle line r layout);
    point_to_line = 
      (fun pt -> point_to_line pt r layout);
    layout;
    container = tr;
    content = glyphs_opt;
    defs = (match glyphs_opt with None -> [] | Some x -> defs_of_glyphs x);
  }
[@@profiling]
@


<<[[draw_treemap_rectangle_content_maybe]]>>=
let draw_treemap_rectangle_content_maybe cr clipping context tr  =
  let r = tr.T.tr_rect in

  if F.intersection_rectangles r clipping =*= None
  then (* pr2 ("not drawing: " ^ file) *) None
  else begin
    let file = tr.T.tr_label in
    Logs.debug (fun m -> m "considering to draw %s" file);

    (* if the file is not textual, or contain weird characters, then
     * it confuses cairo which then can confuse computation done in gtk
     * idle callbacks
     *)
    if Common2_.lfile_exists_eff file && Ftype.is_textual_file (Fpath.v file)
    then begin
      let w = F.rect_width r in
      let h = F.rect_height r in

      let font_size_estimate = h / 100. in
      let font_size_real_estimate = 
        CairoH.user_to_device_font_size cr font_size_estimate in
      if font_size_real_estimate > 0.4
      then begin
       (* Common.nblines_with_wc was really slow. Forking sucks.
        * alt: we could store the nblines of a file in the db.
        *)
        let nblines = Common2_.nblines_eff file |> float_of_int in
        
       (* Assume our code follow certain conventions. Could infer from file. 
        * We should put 80, but a font is higher than large, so I readjusted.
        *)
        let chars_per_column = 41.0 in
    
        let split_nb_columns = 
          optimal_nb_columns ~nblines ~chars_per_column ~h ~w in
        let font_size = 
          font_size_when_have_x_columns ~nblines ~chars_per_column ~h ~w 
            ~with_n_columns:split_nb_columns in

        let layout = {
          nblines;
          lfont_size = font_size;
          split_nb_columns;
          width_per_column = w / split_nb_columns;
          height_per_line = font_size;
          nblines_per_column = (nblines / split_nb_columns) |> ceil;
        } 
        in
        draw_column_bars cr layout r;
        
        Cairo.select_font_face cr Style.font_text ~weight:Cairo.Normal;
    
        let font_size_real = CairoH.user_to_device_font_size cr font_size in
       (*pr2 (spf "file: %s, font_size_real = %f" file font_size_real);*)
    
        if font_size_real > !Flag.threshold_draw_content_font_size_real 
            && not (is_big_file_with_few_lines ~nblines file)
            && nblines < !Flag.threshold_draw_content_nblines
        then Some (draw_content cr layout context tr)
        else None
      end
      else None
    end
    else None
    end
[@@profiling]
@ 

\section{Color code}



\chapter{Macro+Micro View}

\section{Painting}

% also contain the code for calling the micro-level

<<paint>>=
let paint_content_maybe_rect ~user_rect dw model rect =
 with_map dw (fun cr ->
   let context = M.context_of_drawing dw model in
   let clipping = user_rect in
   let microlevel_opt = 
     Draw_microlevel.draw_treemap_rectangle_content_maybe
       cr clipping context rect in
   microlevel_opt |> Option.iter (fun microlevel ->
     Hashtbl.replace dw.microlevel rect microlevel
   );
  (* have to redraw the label *)
   Draw_labels.draw_treemap_rectangle_label_maybe 
     ~cr ~zoom:1.0 ~color:None rect;
 )

(* todo: deadlock:  M.locked (fun () ->  ) dw.M.model.M.m *)
let lazy_paint user_rect dw model () =
  Logs.info (fun m -> m "Lazy Paint");
  let start = Unix.gettimeofday () in
  while Unix.gettimeofday () - start < 0.3 do
    match !Ctl.current_rects_to_draw with
    | [] -> ()
    | x::xs ->
        Ctl.current_rects_to_draw := xs;
        Logs.debug (fun m -> m "Drawing: %s" (x.T.tr_label));
        paint_content_maybe_rect ~user_rect dw model x;
  done;
  !Ctl._refresh_da ();
  if !Ctl.current_rects_to_draw =*= []
  then begin
    !Ctl.hook_finish_paint ();
    !Ctl._refresh_da ();
    false
  end
  (* call me again *)
  else true

let paint dw model = 
  Logs.info (fun m -> m "paint");
  
  !Ctl.paint_content_maybe_refresher |> Option.iter GMain.Idle.remove;
  Ctl.current_rects_to_draw := [];

  let user_rect = device_to_user_area dw in
  UCommon.pr2 (F.s_of_rectangle user_rect);
  let nb_rects = dw.nb_rects in
  let rects = dw.treemap in

  with_map dw (fun cr ->

    (if not (Layer_code.has_active_layers dw.layers)
     (* phase 1, draw the rectangles *)
     then rects |> List.iter (Draw_macrolevel.draw_treemap_rectangle ~cr)
     else rects |> List.iter (Draw_macrolevel.draw_trect_using_layers 
                                ~cr dw.layers)
    );

    (* phase 2, draw the labels, if have enough space *)
    rects |> List.iter (Draw_labels.draw_treemap_rectangle_label_maybe 
                          ~cr ~zoom:1.0  ~color:None);
  );

  (* phase 3, draw the content, if have enough space *)
  if nb_rects < !Flag.threshold_nb_rects_draw_content
  (* draw_content_maybe calls nblines which is quite expensive so
   * want to limit it *)
  then begin
    Ctl.current_rects_to_draw := rects;
    Ctl.paint_content_maybe_refresher := 
        Some (Gui.gmain_idle_add ~prio:3000 (fun () ->
          let res = lazy_paint user_rect dw model () in
          Ctl.paint_content_maybe_refresher := None;
          res
        ));
  end
[@@profiling]
@ 



\section{Mixed view}

<<[[draw_summary_content]]>>=
@ 


<<[[hfiles_and_top_entities]] sig>>=
val hfiles_and_top_entities :
  string (* filename *) -> Database_code.database option -> 
  (string (* filename *), Database_code.entity list) Hashtbl.t
@

<<[[hfiles_and_top_entities]]()>>=
(* used in the summary mixed mode *)
let hfiles_and_top_entities root db_opt =
  let hfiles = Hashtbl.create 1001 in

  db_opt |> Option.iter (fun db ->
    let ksorted = 
      Db.build_top_k_sorted_entities_per_file ~k:5 db.Db.entities in
    let actual_root = actual_root_of_db ~root db in

    Hashtbl.iter (fun k v ->
      let k' = Filename.concat actual_root k in
      Hashtbl.add hfiles k' v
    ) ksorted
  );
  hfiles
@

<<model fields hook>>=
@ 

\chapter{Layers}

\section{Micro-level}

\begin{verbatim}
This is kind of intra-file "aspect"
\end{verbatim}

\section{Macro-level}

% need majority when multiple match same file ?

\begin{verbatim}
This is kind of inter-file "aspect". See also
the regular archi_code treemap which is also
about aspects.
\end{verbatim}

\section{UI}

<<ui_layers.mli>>=
val choose_layer: 
  root:string ->
  string option (* layer title we want *) -> 
  Model.world -> 
  unit
@ 

<<ui_layers.ml>>=
<<Facebook copyright>>
open Common
open Model
module M = Model
module L = Layer_code

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

let choose_layer ~root layer_title_opt w =
  UCommon.pr2 "choose_layer()";
  let dw = w.dw in

  let original_layers = dw.M.layers.L.layers |> List.map fst in
  let layers_idx = 
    Layer_code.build_index_of_layers 
      ~root
      (original_layers |> List.map (fun layer ->
        layer, 
        match layer_title_opt with
        | None -> false
        | Some title -> title = layer.L.title
      ))
  in
  w.dw <- 
    Model.init_drawing 
      ~width:dw.width
      ~height:dw.height
      w.treemap_func 
      layers_idx
      [root]
      root;
  View_mainmap.paint w.dw w.model;
  !Controller._refresh_da ();
  !Controller._refresh_legend ();
  ()

@ 


\chapter{Navigation}

<<[[key_pressed]]>>=
@ 


<<[[find_filepos_in_rectangle_at_user_point]]>>=
@ 

<<[[text_with_user_pos]] sig>>=
@ 


<<[[button_action]]>>=
let button_action w ev =
  let dw = w.dw in

  let x, y = GdkEvent.Button.x ev, GdkEvent.Button.y ev in
  let user = with_map dw (fun cr -> 
    Cairo.device_to_user cr x y |> CairoH.cairo_point_to_point ) in
  let r_opt = M.find_rectangle_at_user_point user dw in

  match GdkEvent.get_type ev with
  | `BUTTON_PRESS ->
      let button = GdkEvent.Button.button ev in
      let state = GdkEvent.Button.state ev in
      UCommon.pr2 (spf "button %d pressed" button);
      (match button with
      | 1 -> 
        r_opt |> Option.iter (fun (r, _, _r_englobing) ->
          let file = r.T.tr_label in
          UCommon.pr2 (spf "clicking on %s" file);
        );
        true
      | 2 ->
        r_opt |> Option.iter (fun (r, _, _r_englobing) ->
          let file = r.T.tr_label in
          UCommon.pr2 (spf "opening %s" file);
          let line = 
            M.find_line_in_rectangle_at_user_point user r dw ||| (Line 0)
          in
          Editor_connection.open_file_in_current_editor ~file ~line;
        );
        true

      | 3 ->
        r_opt |> Option.iter (fun (tr, _, _r_englobing) ->
          (* actually file_or_dir *)
          let file = tr.T.tr_label in

          if not (Gdk.Convert.test_modifier `SHIFT state)
          then !Ctl._go_dirs_or_file w [file]
          else begin

          let model = Async.async_get w.model in

          (* similar to View_overlays.motion.refresher *)
          let line_opt = 
            M.find_line_in_rectangle_at_user_point user tr dw in
          let glyph_opt =
            M.find_glyph_in_rectangle_at_user_point user tr dw in
          let entity_def_opt = 
            let* line = line_opt in
            M.find_def_entity_at_line_opt line tr dw model in
          let entity_use_opt =
            let* line = line_opt in
            let* glyph = glyph_opt in
            M.find_use_entity_at_line_and_glyph_opt line glyph tr dw model
          in
          let entity_opt = 
            match entity_use_opt, entity_def_opt with
            (* priority to use *)
            | Some e, Some _ -> Some e
            | Some e, _ | _, Some e -> Some e
            | _ -> None
          in
          let n = entity_opt ||| M.node_of_rect tr model in
        
          let uses, users = M.deps_readable_files_of_node n model in

          let paths_of_readables xs = 
            xs 
            |> List.sort compare
            |> Common2.uniq
            (* todo: tfidf to filter files like common2.ml *)
            |> List_.exclude (fun readable -> 
                readable =~ "commons/common2.ml"
                (*readable =~ "external/.*"  *)
            )
            |> List.map (fun s -> Filename.concat model.root s)
            (* less: print a warning when does not exist? *)
            |> List.filter Sys.file_exists
          in
          let readable = (Filename_.readable ~root:(model.root) (file)) in
          let readable =
            match entity_opt with
            | None -> readable
            | Some n -> 
                let g = Common2_.some model.g in
                try !!(Graph_code.file_of_node n g)
                with Not_found -> readable
          in
          let entries = [
            `I ("go to file", (fun () -> 
              !Ctl._go_dirs_or_file w (paths_of_readables [readable]);));
            `I ("deps inout", (fun () -> 
              w.current_node_selected <- entity_opt;
              !Ctl._go_dirs_or_file w (paths_of_readables 
                                         (uses @ users @ [readable]))));
            `I ("deps in (users)", (fun () -> 
              w.current_node_selected <- entity_opt;
              !Ctl._go_dirs_or_file w (paths_of_readables (users@[readable]))));
            `I ("deps out (uses)", (fun () -> 
              w.current_node_selected <- entity_opt;
              !Ctl._go_dirs_or_file w (paths_of_readables (uses@[readable]))));
            `I ("info file", (fun () -> 
              let microlevel = Hashtbl.find dw.microlevel tr in
              let defs = microlevel.defs in
              let buf = Buffer.create 100 in
              let prx s = Buffer.add_string buf (s ^ "\n") in
              prx "short defs";
              defs |> List.iter (fun (_line, short_node) ->
                  prx (" " ^ Graph_code.string_of_node short_node)
              );
              Gui.dialog_text ~text:(Buffer.contents buf) ~title:"Info file";
            ));
          ] in
          let entries = 
            entries @
            (match entity_opt with
            | None -> []
            | Some n ->
                let g = Common2_.some model.g in
                [`I ("info entity", (fun () ->
                  let users = Graph_code.pred n (Graph_code.Use) g in
                  let str =
                    ([Graph_code.string_of_node n] @
                    (users |> List.map Graph_code.string_of_node )
                    ) |> String.concat "\n"
                  in
                  Gui.dialog_text ~text:str ~title:"Info entity";
                ));
                 `I ("goto def", (fun () ->
                   w.current_node_selected <- entity_opt;
                   let dest = !!(Graph_code.file_of_node n g) in
                   !Ctl._go_dirs_or_file w (paths_of_readables [dest])
                 ));                                              
                ]
            )
          in
          GToolbox.popup_menu ~entries ~button:3 
            ~time:(GtkMain.Main.get_current_event_time());
          end
        );
        true
      | _ -> false
      )
  | `BUTTON_RELEASE ->
      let button = GdkEvent.Button.button ev in
      UCommon.pr2 (spf "button %d released" button);
      (match button with
      | 1 -> true
      | _ -> false
      )

  | `TWO_BUTTON_PRESS ->
      UCommon.pr2 ("double click");
      r_opt |> Option.iter (fun (_r, _, r_englobing) ->
        let path = r_englobing.T.tr_label in
        !Ctl._go_dirs_or_file w [path];
      );
      true
  | _ -> false
@ 



\section{Zooming in a directory}


<<[[go_dirs_or_file]]>>=
let go_dirs_or_file ?(current_grep_query=None) w paths =
  let root = Common2_.common_prefix_of_files_or_dirs paths in
  UCommon.pr2 (spf "zooming in %s" (String.concat "|" paths));

  (* reset the painter? not needed because will call draw below
   * which will reset it
   *)
  let dw = w.dw in
  !Controller._set_title (Controller.title_of_path root);

  Stack_.push w.dw w.dw_stack;
  w.dw <- 
    Model.init_drawing 
      ~width:dw.width
      ~height:dw.height
      w.treemap_func 
      dw.layers
      paths
      w.root_orig;
  (match current_grep_query with
  | Some h -> w.dw.current_grep_query <- h;
  (* wants to propagate the query so when right-click the query
   * is still there  *)
  | None -> w.dw.current_grep_query <- dw.current_grep_query;
  );
  View_overlays.paint_initial w.dw;
  View_mainmap.paint w.dw w.model;
  !Controller._refresh_da ();
  ()
@ 


<<[[find_rectangle_at_user_point]] sig>>=
val find_rectangle_at_user_point :
  Figures.point -> drawing ->
  (Treemap.treemap_rectangle * (* most precise *)
   Treemap.treemap_rectangle list * (* englobbing ones *)
   Treemap.treemap_rectangle (* top one *)
  ) option
@

<<[[find_rectangle_at_user_point]]()>>=
(* alt: we could use Cairo_bigarray and the pixel trick below if
 * it takes too long to detect which rectangle is under the cursor.
 * We could also sort the rectangles ... or have some kind of BSP.
 * Add in model:
 *   mutable pm_color_trick: GDraw.pixmap;
 *   mutable pm_color_trick_info: (string) array.
 * 
 * current solution: just find pixel by iterating over all the rectangles
 * and check if it's inside.
 *)
let find_rectangle_at_user_point user dw =

  let rects = dw.treemap in
  if List.length rects =|= 1
  then 
    (* we are fully zommed, this treemap will have tr_depth = 1 but we return
     * it *)
    let x = List.hd rects in
    Some (x, [], x)
  else 
   let matching_rects = rects 
    |> List.filter (fun r -> 
        F.point_is_in_rectangle user r.T.tr_rect && r.T.tr_depth > 1
    ) 
    |> List.map (fun r -> r, r.T.tr_depth) 
    (* opti: this should be far faster by using a quad tree to represent
     * the treemap
     *)
    |> Assoc.sort_by_val_highfirst 
    |> List.map fst
   in
   match matching_rects with
   | [] -> None
   | [x] -> Some (x, [], x)
   | _ -> Some (Common2_.head_middle_tail matching_rects)
[@@profiling]
@

\section{Zooming in multiple directories}

\begin{verbatim}
see multi dir search
\end{verbatim}

\section{Zooming in a file}

\section{Opening a file in an external editor}

<<editor_connection.mli>>=

val emacsclient_path: string ref
val efunsclient_path: string ref

val open_file_in_current_editor: file:string -> line:Model.line -> unit
@ 

<<emacs configuration>>=
(*
let emacsclient_path_mac =
  "/home/pad/Dropbox/apps/Emacs.app/Contents/MacOS/bin/emacsclient"
*)

let emacsclient_path = ref "emacsclient"
let efunsclient_path = ref "efunsclient"

(* you need to have done a M-x server-start first *)
let run_emacsclient ~file ~line =
  Sys.command (spf "%s -n %s" !emacsclient_path file) |> ignore;
  Sys.command (spf 
    "%s -e '(with-current-buffer (window-buffer (selected-window)) (goto-line %d))'"
    !emacsclient_path line) |> ignore;
  ()

(* you need to have done a M-x server_start first *)
let run_efunsclient ~file ~line =
  Sys.command (spf "%s %s -line %d" !efunsclient_path file line) |> ignore

@


<<[[open_file_in_current_editor]]()>>=
let open_file_in_current_editor ~file ~line =
  let (Model.Line line) = line in
  (* emacs/efuns line numbers start at 1 *)
  let line = line + 1 in
  run_efunsclient ~file ~line;
  run_emacsclient ~file ~line;
@


\section{Going back}

<<[[go_back]]>>=
let go_back w = 
  (* reset also the motion notifier ? less needed because
   * the next motion will reset it
   *)
  !Controller.paint_content_maybe_refresher |> Option.iter (fun x ->
    GMain.Idle.remove x;
  );
  let old_dw = Stack_.pop w.dw_stack in
  w.dw <- old_dw;
 
  let path = w.dw.current_root in
  !Controller._set_title (Controller.title_of_path path);
  !Controller._refresh_da();
  ()
@ 

\section{Magnifying glass}

%Incruste Mode

<<idle>>=
@ 


\section{Minimap}


<<[[motion_notify_minimap]]>>=
@ 


<<[[button_action_minimap]]>>=
@ 


<<[[paint_minimap]]>>=
@ 


<<[[expose_minimap]]>>=
@ 


<<[[configure_minimap]]>>=
@ 


<<[[with_minimap]]>>=
@ 

<<fields drawing minimap>>=
@

<<[[scale_minimap]]>>=
@ 


\section{Fine-grained pan and zoom}


<<[[with_map]]>>=
let with_map dw f = 
  let cr = Cairo.create dw.base in
  zoom_pan_scale_map cr dw;
  f cr
@ 

<<[[zoom_pan_scale_map]]>>=
let zoom_pan_scale_map cr dw =
  Cairo.scale cr 
    (float_of_int dw.width / !T.xy_ratio)
    (float_of_int dw.height)
  ;
  (* I first scale and then translate as the xtrans are in user coordinates *)
  Cairo.translate cr 0.0 0.0;
  ()
@ 

<<fields drawing viewport>>=
(* viewport, device coordinates *)
mutable width: int;
mutable height: int;
@

\chapter{Search}

<<[[dialog_search_def]]>>=
let dialog_search_def model = 
  let idx = (fun () -> 
    let model : Model.model = Async.async_get model in
    model.big_grep_idx 
  )
  in
  let entry = 
    Completion.my_entry_completion_eff 
      ~callback_selected:(fun _entry _str _file _e ->
        true
      )
      ~callback_changed:(fun _str ->
        ()
      )
      idx
  in

  let res =
    G.dialog_ask_generic ~title:"" 
      (fun vbox -> 
        vbox#pack (G.with_label "search:" entry#coerce);
      )
      (fun () -> 
        let text = entry#text in 
        UCommon.pr2 text;
        text
      )
  in
  res |> Option.iter (fun s -> 
    UCommon.pr2 ("selected: " ^ s);
  );
  res
@ 


<<[[run_grep_query]]>>=
let run_grep_query ~root s =
  (* --cached so faster ? use -w ?  
   * -I means no search for binary files
   * -n to show also line number
   *)
  let git_grep_options = 
    "-I -n"
  in
  let cmd = 
    spf "cd %s; git grep %s %s" root git_grep_options s
  in
  let xs = UCmd.cmd_to_list cmd in
  let xs = xs |> List.map (fun s ->
    if s =~ "\\([^:]*\\):\\([0-9]+\\):.*"
    then
      let (filename, lineno) = Common.matched2 s in
      let lineno = s_to_i lineno in
      let fullpath = Filename.concat root filename in
      fullpath, (M.Line (lineno - 1))
    else 
      failwith ("wrong git grep line: " ^ s)
  ) in
  xs
@ 


<<[[run_tbgs_query]]>>=
let run_tbgs_query ~root s =
  let cmd = 
    spf "cd %s; tbgs --stripdir %s" root s
  in
  let xs = UCmd.cmd_to_list cmd in
  let xs = xs |> List.map (fun s ->
    if s =~ "\\([^:]*\\):\\([0-9]+\\):.*"
    then
      let (filename, lineno) = Common.matched2 s in
      let lineno = s_to_i lineno in
      let fullpath = Filename.concat root filename in
      fullpath, (M.Line (lineno - 1))
    else 
      failwith ("wrong tbgs line: " ^ s)
  ) in
  xs
@ 



<<fields drawing query stuff>>=
(* queries *)
mutable current_query: string;
mutable current_searched_rectangles: Treemap.treemap_rectangle list;
mutable current_grep_query: (string (* filename *), line) Hashtbl.t;
@

\section{Definition search}

\begin{verbatim}
%tags-like

% php manual integration!
\end{verbatim}



<<[[all_entities]] sig>>=
(* Will generate extra entities for files, dirs, and also generate
 * an extra entity when have a fullname that is not empty
 *)
val all_entities :
  root:string (* filename *) -> string (* filename *) list -> Database_code.database option->
  Database_code.entity list
@



\subsubsection{Completion building}

<<signature [[build_completion_defs_index]]>>=
val build_completion_defs_index : 
  Database_code.entity list -> Big_grep.index
@ 

<<[[build_completion_defs_index]]>>=
(* I was previously using a prefix-clustering optimisation but it
 * does not allow suffix search. Moreover it was still slow so
 * Big_grep is just simpler and better.
 *)

let build_completion_defs_index all_entities = 
  BG.build_index all_entities
@ 

\subsubsection{Completion window}

<<signature [[my_entry_completion_eff]]>>=

val my_entry_completion_eff :
  callback_selected:
   (GEdit.entry -> string -> string -> Database_code.entity -> bool) ->
  callback_changed:(string -> unit) -> 
  (unit -> Big_grep.index) ->
  GEdit.entry
@ 

<<model fields hook>>=
big_grep_idx: Big_grep.index;
@ 

\begin{verbatim}
%tags-like

% for func/class/methods/ files and dirs!
\end{verbatim}


<<[[all_entities]]>>=
(* To get completion for functions/class/methods/files/directories.
 * 
 * We pass the root in addition to the db_opt because sometimes we 
 * don't have a db but we still want to provide completion for the 
 * dirs and files.
 * 
 * todo: what do do when the root of the db is not the root
 * of the treemap ?
 *)
let all_entities ~root files db_opt =
  match db_opt with
  | None -> 
      let db = Database_code.files_and_dirs_database_from_files ~root files in
      Database_code.files_and_dirs_and_sorted_entities_for_completion
        ~threshold_too_many_entities:!Flag.threshold_too_many_entities
        db

  | Some db ->
      let nb_entities = Array.length db.Db.entities in
      let nb_files = List.length db.Db.files in
      UCommon.pr2 (spf "We got %d entities in %d files" nb_entities nb_files);

      (* the db passed might be just about .ml files but we could be
       * called on a directory with non .ml files that we would
       * still want to quicky jump too hence the need to include
       * other regular files and dirs
       *)
      let db2 = Database_code.files_and_dirs_database_from_files ~root files in
      let db = Database_code.merge_databases db db2 in

      Database_code.files_and_dirs_and_sorted_entities_for_completion
        ~threshold_too_many_entities:!Flag.threshold_too_many_entities
        db
@




<<Completion.ml>>=
<<Facebook copyright>>
open Common

module G = Gui
module E = Entity_code
module Db = Database_code
module BG = Big_grep
module Flag = Flag_visual
module HC = Highlight_code

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(*
 * Gtk (and lablgtk) is very fragile; if you change what looks like
 * an innocent line, you might suddenly get performance regressions
 * or new Gtk warnings at runtime. So take care when changing this file.
 *
 * todo:
 *  - http://jeremymikkola.com/posts/2019_03_19_rules_for_autocomplete.html
 *)

(*****************************************************************************)
(* Code indexing *)
(*****************************************************************************)

<<[[build_completion_defs_index]]>>

(*****************************************************************************)
(* Icons *)
(*****************************************************************************)

(* Many IDEs use icons to represent entities:
 *  - https://docs.microsoft.com/en-us/visualstudio/ide/class-view-and-object-browser-icons?view=vs-2015
 *  - http://help.eclipse.org/kepler/index.jsp?topic=/org.eclipse.jdt.doc.user/reference/ref-icons.htm
 *  - https://www.jetbrains.com/help/idea/symbols.html
 *  - https://github.com/patrys/vscode-code-outline/tree/master/resources/light
 *    (just 8 icons, and not great one)
 *  - https://atom.io/packages/structure-view
 *    (very few icons too)
 *
 * I originally used icons to reprensent entities, first from Gtk Stock icons
 * (ugly) and later from Eclipse, but in the end those icons were not
 * super readable not universal, and were mostly for OO languages.
 * Using the color scheme of info_of_entity_kind_and_usedef2 is simpler
 * and better.
 * If you want to bring back icons, look at the history of the file to
 * get back the relevant code.
 *)

(*****************************************************************************)
(* Colors *)
(*****************************************************************************)

let color_of_entity_kind kind =
  (* less: could use count to even have color depending on count *)
  let use = HC.SomeUse in
  let props = HC.info_of_entity_kind_and_usedef2 kind (HC.Def2 use) in
  let color = 
    try props |> List_.find_some (function
        | `FOREGROUND s -> Some s
        | _ -> None
      )
    with Not_found -> 
        failwith (spf "could not find a FOREGROUND color for entity %s"
          (Entity_code.string_of_entity_kind kind))
  in
  color

(*****************************************************************************)
(* Model *)
(*****************************************************************************)

let column_list = new GTree.column_list
(* old:
 *  let col_full = (column_list#add Gobject.Data.caml: t GTree.column)
 * this works only with a custom list model :( but those models seem to not
 * work anymore inside completion boxes :( so instead I use a col_id
 * and a store_id_to_entity hash to get equivalent functionality.
 *)
let col_id   = column_list#add Gobject.Data.int
let col_text = column_list#add Gobject.Data.string
let col_file = column_list#add Gobject.Data.string
let col_count = column_list#add Gobject.Data.string
(* To colorize the foreground of col_text.
 * less: could also colorize the background and could also colorize
 * col_file (using dircolors.ml color coding)
 *)
let col_color_fg = column_list#add Gobject.Data.string
let col_color_bg = column_list#add Gobject.Data.string


let model_of_list_pair_string_with_icon xs =

  (* old: I was using before a custom_list 
   * (see custom_list_generic.ml in lablgtk2/examples)
   * to be faster because GTree.tree_store used to be really slow.
   * However, I am now unable to make it work with recent gtk/lablgtk2
   * (I get some failure assertions regarding GtkModelFilter)
   * so I reverted back to using the simpler tree_store which in 2019
   * seems ok.
   *)
  let model = GTree.tree_store column_list in
  let store_id_to_entity = Hashtbl.create 101 in

  UCommon.pr2 (spf "Size of model = %d" (List.length xs));
  xs |> List_.index_list_0 |> List.iter (fun (e, id) ->
   
    let _has_unit_test =
      List.length e.Db.e_good_examples_of_use >= 1
    in
    let name = e.Db.e_name in

    (* if the string is too long, we will not see the other properties *)
    let final_name = 
      try (String.sub name 0 30) ^ "..."
      with Invalid_argument _ -> name
    in
    let color = color_of_entity_kind e.Db.e_kind in

    let row = model#append () in

    model#set ~row ~column:col_id id;
    (* I had originally an ugly hack where I would artificially create
     * a text2 field with always set to query. Indeed
     * gtk seems to be confused if the column referenced
     * by set_text_column contains a string that is not matching
     * the current query. So here I was building this fake text entry.
     * In fact as explained on the pygtk entry of entry_completion
     * you don't have to use set_text_column if you provide
     * your own set_match_func, which I do now.
     * Maybe we should just not use Entrycompletion at all and build
     * our own popup.
     *)
    model#set ~row ~column:col_text final_name;
    model#set ~row ~column:col_count (i_to_s (e.Db.e_number_external_users));
    model#set ~row ~column:col_file e.Db.e_file;
    model#set ~row ~column:col_color_fg color;
    model#set ~row ~column:col_color_bg "DarkSlateGray";

    Hashtbl.add store_id_to_entity id e;
  );
  model, store_id_to_entity
[@@profiling]

let model_col_of_prefix prefix_or_suffix idx =
  let xs = 
    BG.top_n_search 
      ~top_n:!Flag.top_n
      ~query:prefix_or_suffix 
      idx
  in
  model_of_list_pair_string_with_icon xs

(*****************************************************************************)
(* Main entry point *)
(*****************************************************************************)

let add_renderer (completion : GEdit.entry_completion) =
  
  let renderer = GTree.cell_renderer_text [] in
  completion#pack (renderer :> GTree.cell_renderer);
  completion#add_attribute (renderer :> GTree.cell_renderer) 
    "text" col_text;
  completion#add_attribute (renderer :> GTree.cell_renderer) 
    "foreground" col_color_fg;
  completion#add_attribute (renderer :> GTree.cell_renderer) 
    "background" col_color_bg;

  let renderer = GTree.cell_renderer_text [`WIDTH 80] in
  completion#pack (renderer :> GTree.cell_renderer);
  completion#add_attribute (renderer :> GTree.cell_renderer) 
    "text" col_count;

  let renderer = GTree.cell_renderer_text [] in
  completion#pack (renderer :> GTree.cell_renderer);
  completion#add_attribute (renderer :> GTree.cell_renderer) 
    "text" col_file;

  ()
  

let fake_entity = {Database_code.
     e_name = "foobar";
     e_fullname = "";
     e_file = "foo.php";
     e_kind = E.Function;
     e_pos = { Pos.l = -1; c = -1 };
     e_number_external_users = 0;
     e_good_examples_of_use = [];
     e_properties = [];
}

let my_entry_completion_eff2 ~callback_selected ~callback_changed fn_idx = 
  
  let entry = GEdit.entry ~width:1100 () in
  let completion = GEdit.entry_completion () in
  entry#set_completion completion;

  let xs = [ fake_entity ] in
  let model_dumb, h_dumb = model_of_list_pair_string_with_icon xs in
  let model = ref model_dumb in
  let store_id_to_entity = ref h_dumb in

  add_renderer completion;
  completion#set_model (!model :> GTree.model);

  (* we don't use the builtin gtk completion mechanism because we
   * recompute the model each time using big_grep so here
   * we just always return true. Moreover, the builtin gtk
   * function would do a is_prefix check between the row
   * and the current query which in our case would fail because
   * we want the suffix-search ability of big_grep.
   *)
  completion#set_match_func (fun _key _row ->
    true
  );
  completion#set_minimum_key_length 2;

  completion#connect#match_selected (fun _model_filter row ->
     (* note: the code below used to not work; the row was relative to the
      * model_filter.
      *  let str = !model#get ~row ~column:col1 in
      *  let file = !model#get ~row ~column:col2 in
      * update: I now get assetions failures when using model_filter so
      *  I am now using back again !model.
      * old: 
      *  let model = model_filter#child_model in
      *  let row = model_filter#convert_iter_to_child_iter row in
      * does not work anymore
      *)

      let str =  !model#get ~row ~column:col_text in
      let file = !model#get ~row ~column:col_file in

      (* old: 
       * let t =   model#get ~row ~column:col_full in
       * unfortunately this does seem to work only with custom list
       *)
      let id = !model#get ~row ~column:col_id in
      let entity = Hashtbl.find !store_id_to_entity id in

      UCommon.pr2 str;
      UCommon.pr2 file;
      callback_selected entry str file entity

  ) |> ignore;

  let current_timeout = ref None in

  entry#connect#changed (fun () -> 
    let s = entry#text in
    UCommon.pr2 s;
    if s <> "" then begin
      !current_timeout |> Option.iter (fun x ->
        GMain.Timeout.remove x;
      );
      current_timeout :=
        Some 
          (G.gmain_timeout_add ~ms:250
           ~callback:(fun _ -> 
            (* bugfix: reset it otherwise get Glib errors *)
            current_timeout := None;
            UCommon.pr2 "changing model";
            let idx = fn_idx () in
            let (m,h) = model_col_of_prefix s idx in
            model := m;
            store_id_to_entity := h;
            completion#set_model (!model :> GTree.model);

            callback_changed s;
            false
          ));
    end
    else callback_changed s
  ) |> ignore;

  (* return the entry so someone can hook another signal *)
  entry
 
let my_entry_completion_eff ~callback_selected ~callback_changed x = 
  my_entry_completion_eff2 ~callback_selected ~callback_changed x

@ 

\section{Use Search, aka Visual [[grep]]}


\begin{verbatim}
%cscope-like
% see also layers
\end{verbatim}


\section{Directory search}

\begin{verbatim}
%multi dirs
\end{verbatim}

\section{Multi-directories}

\section{Example search}

\begin{verbatim}
%test search

% pleac integration!
\end{verbatim}


\chapter{Overlays}

% draw vs paint vs xxx

\section{Cairo overlays}

\begin{verbatim}
aka layers
similar but different from the  layers in prevision section.
Here low level graphics layers.
\end{verbatim}

<<fields drawing main view>>=
(* device coordinates *)
(* first cairo layer, for heavy computation e.g. the treemap and content*)
mutable base: Cairo.Surface.t;
(* second cairo layer, when move the mouse *)
mutable overlay: Cairo.Surface.t;
(* todo? third cairo layer? for animations and time related graphics such
 * as tooltips, glowing rectangles, etc?
 *)
@

\section{Rectangle overlay}

<<[[draw_rectangle_overlay]]>>=
let draw_englobing_rectangles_overlay ~dw (r, middle, r_englobing) =
 with_overlay dw (fun cr_overlay ->
  CairoH.draw_rectangle_figure 
    ~cr:cr_overlay ~color:"white" r.T.tr_rect;
  CairoH.draw_rectangle_figure
    ~cr:cr_overlay ~color:"blue" r_englobing.T.tr_rect;

  Draw_labels.draw_treemap_rectangle_label_maybe 
    ~cr:cr_overlay ~color:(Some "red") ~zoom:1.0 r_englobing;

  middle |> List_.index_list_1 |> List.iter (fun (r, i) ->
    let color = 
      match i with
      | 1 -> "grey70"
      | 2 -> "grey40"
      | _ -> spf "grey%d" (max 1 (50 -.. (i *.. 10)))
    in
    CairoH.draw_rectangle_figure
      ~cr:cr_overlay ~color r.T.tr_rect;
    Draw_labels.draw_treemap_rectangle_label_maybe 
      ~cr:cr_overlay ~color:(Some color) ~zoom:1.0 r;
  );
 )
@ 


\section{Label overlay}

<<[[draw_label_overlay]]>>=
(* assumes cr_overlay has not been zoom_pan_scale *)
let draw_label_overlay ~cr_overlay ~x ~y txt =

  Cairo.select_font_face cr_overlay "serif" ~weight:Cairo.Normal;
  Cairo.set_font_size cr_overlay Style.font_size_filename_cursor;
      
  let extent = CairoH.text_extents cr_overlay txt in
  let tw = extent.Cairo.width in
  let th = extent.Cairo.height in

  let refx = x - tw / 2. in
  let refy = y in

  CairoH.fill_rectangle ~cr:cr_overlay 
    ~x:(refx + extent.Cairo.x_bearing) ~y:(refy + extent.Cairo.y_bearing)
    ~w:tw ~h:(th * 1.2)
    ~color:"black"
    ~alpha:0.5
    ();

  Cairo.move_to cr_overlay refx refy;
  Cairo.set_source_rgba cr_overlay 1. 1. 1.    1.0;
  CairoH.show_text cr_overlay txt;
  ()
@ 

\section{Searched files overlay}

<<[[draw_searched_rectangles]]>>=
let draw_searched_rectangles ~dw =
 with_overlay dw (fun cr_overlay ->
  dw.current_searched_rectangles |> List.iter (fun r ->
    CairoH.draw_rectangle_figure ~cr:cr_overlay ~color:"yellow" r.T.tr_rect
  );
  (* 
   * would also like to draw not matching rectangles
   * bug the following code is too slow on huge treemaps. 
   * Probably because it is doing lots of drawing and alpha
   * computation.
   *
   * old:
   * let color = Some "grey3" in
   * Draw.draw_treemap_rectangle ~cr:cr_overlay 
   * ~color ~alpha:0.3
   * r
   *)
 )
@ 

\section{Zoom overlay}

<<[[zoomed_surface_of_rectangle]]>>=
@ 

\section{Assembling overlays}

<<[[motion_refresher]]>>=
let motion_refresher ev w =
  paint_initial w.dw;
  hook_finish_paint w;
  let dw = w.dw in
  let cr_overlay = Cairo.create dw.overlay in

  (* some similarity with View_mainmap.button_action handler *)
  let x, y = GdkEvent.Motion.x ev, GdkEvent.Motion.y ev in
  let user = View_mainmap.with_map dw (fun cr -> 
    Cairo.device_to_user cr x y |> CairoH.cairo_point_to_point) in
  let r_opt = M.find_rectangle_at_user_point user dw in

  r_opt |> Option.iter (fun (tr, middle, r_englobing) ->
    (* coupling: similar code in right click handler in View_mainmap *)
    let line_opt = 
      M.find_line_in_rectangle_at_user_point user tr dw in
    let glyph_opt =
      M.find_glyph_in_rectangle_at_user_point user tr dw in

    let entity_def_opt = 
      let* model = Async.async_get_opt w.model in
      let* line = line_opt in
        M.find_def_entity_at_line_opt line tr dw model in
    let entity_use_opt =
      let* model = Async.async_get_opt w.model in
      let* line = line_opt in
      let* glyph = glyph_opt in
      M.find_use_entity_at_line_and_glyph_opt line glyph tr dw model
    in
    let entity_opt = 
      match entity_use_opt, entity_def_opt with
      (* priority to use *)
      | Some e, Some _ -> Some e
      | Some e, _ | _, Some e -> Some e
      | _ -> None
    in

    let statusbar_txt = 
      tr.T.tr_label ^
      (match line_opt with None -> "" | Some (Line i) -> 
        spf ":%d" i) ^
      (match glyph_opt with None -> "" | Some glyph -> 
        spf "[%s]" glyph.str) ^
      (match entity_def_opt with None -> "" | Some n -> 
        spf "(%s)" (Graph_code.string_of_node n)) ^
      (match entity_use_opt with None -> "" | Some n -> 
        spf "{%s}" (Graph_code.string_of_node n))
    in
    !Controller._statusbar_addtext statusbar_txt;

    (match line_opt with
    | None ->
        let label_txt = readable_txt_for_label tr.T.tr_label dw.current_root in
        draw_label_overlay ~cr_overlay ~x ~y label_txt
    | Some line ->
        let microlevel = Hashtbl.find dw.microlevel tr in
        draw_magnify_line_overlay_maybe ~honor_color:true dw line microlevel
    );

    draw_englobing_rectangles_overlay ~dw (tr, middle, r_englobing);
    Async.async_get_opt w.model |> Option.iter (fun model ->
      draw_deps_files tr dw model;
      entity_opt |> Option.iter (fun _n -> w.current_node <- None);
      entity_def_opt|>Option.iter (fun n -> draw_deps_entities n dw model);
      entity_use_opt|>Option.iter (fun n -> draw_deps_entities n dw model);
    );
  
    if w.settings.draw_searched_rectangles;
    then draw_searched_rectangles ~dw;

    !Controller.current_tooltip_refresher
      |> Option.iter GMain.Timeout.remove;
    Controller.current_tooltip_refresher := 
      Some (Gui.gmain_timeout_add ~ms:1000 ~callback:(fun _ ->
        Async.async_get_opt w.model |> Option.iter (fun model ->
          match entity_opt, model.g with
          | Some node, Some g ->
            draw_tooltip ~cr_overlay ~x ~y node g;
            !Controller._refresh_da ();
          | _ -> ()
          ;
        );
        Controller.current_tooltip_refresher := None;
        (* do not run again *)
        false
      ));
    
    Controller.current_r := Some tr;
  );
  !Controller._refresh_da ();
  false


let motion_notify w ev =
(*  let x, y = GdkEvent.Motion.x ev, GdkEvent.Motion.y ev in *)
(*  pr2 (spf "motion: %f, %f" x y); *)

  (* The motion code now takes time, so it's better do run it when the user
   * has finished moving his mouse, hence the use of gmain_idle_add below.
   *)
  !Controller.current_motion_refresher |> Option.iter GMain.Idle.remove;
  Controller.current_motion_refresher := 
    Some (Gui.gmain_idle_add ~prio:200 (fun () -> 
      let res = motion_refresher ev w in
      Controller.current_motion_refresher := None;
      res
    ));
  true
@ 


\chapter{Final Rendering}

\section{The big picture}

\begin{verbatim}

\end{verbatim}


\section{The [[configure]] event}

<<configure>>=
let configure w ev = 
  let dw = w.dw in
  let width = GdkEvent.Configure.width ev in
  let height = GdkEvent.Configure.height ev in
  dw.width <- width;
  dw.height <- height;
  dw.base <- Model.new_surface ~alpha:false ~width ~height;
  dw.overlay <- Model.new_surface ~alpha:true ~width ~height;
  View_mainmap.paint dw w.model;
  true
[@@profiling]
@ 


\section{The [[expose]] event}

<<[[assemble_layers]]>>=
(* Composing the "layers". See cairo/tests/knockout.ml example.
 * Each move of the cursor will call assemble_layers which does all
 * those pixels copying (which is very fast).
 * 
 * The final target is the actual gtk window which is represented by cr_final.
 * We copy the pixels from the pixmap dw.pm on the window. Then
 * we copy the pixels from the pixmap dw.overlay on the window
 * getting the final result.
 *)
let assemble_layers cr_final dw =
  let surface_src = dw.base in

  Cairo.set_operator cr_final Cairo.OVER;
  Cairo.set_source_surface cr_final surface_src 0. 0.;
  Cairo.paint cr_final;

  Cairo.set_operator cr_final Cairo.OVER;
  Cairo.set_source_surface cr_final dw.overlay 0. 0.;
  Cairo.paint cr_final;
  ()
@ 


<<expose>>=
(* opti: don't 'paint dw;' painting is the computation
 * heavy function. expose() just copy the "canvas" layers.
 *)
let expose da w _ev = 
  let dw = w.dw in
  let gwin = da#misc#window in
  let cr = Cairo_gtk.create gwin in
  assemble_layers cr dw;
  true
[@@profiling]
@ 


\section{Trace: clicking a directory}

\begin{verbatim}
diagram where see events, functions,  draw vs paint vs overlays.
\end{verbatim}

\section{Trace: moving the mouse}

\begin{verbatim}
diagram where see events, functions,  draw vs paint vs overlays.
\end{verbatim}


\chapter{Language Modes}

\section{Parsing}

<<Parsing.mli>>=

(* internally memoize the parsing part in _hmemo_file *)
val tokens_with_categ_of_file:
  string (* filename *) ->
  (string, Database_code.entity) Hashtbl.t ->
  (string * Highlight_code.category option * Pos.linecol) list

(* helpers *)
val use_arity_of_use_count: 
  int -> Highlight_code.use_arity

@ 


\section{Generic semantic visual feedback}

<<Parsing.ml>>=
<<Facebook copyright>>
open Common

open Highlight_code
module FT = Ftype
module HC = Highlight_code
module Db = Database_code
module Flag = Flag_visual
module PH = Parse_and_highlight

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* 
 * The main entry point of this module is tokens_with_categ_of_file
 * which is called in Draw_microlevel to "render" the content of a file.
 *)

(*****************************************************************************)
(* Parsing helpers *)
(*****************************************************************************)

(* This type is needed if we want to use a single hashtbl to memoize
 * all the parsed file.
 * Now that a few language highlighters rely internaly on a generic AST and
 * highlight_AST.ml, should we also memoized the (named) generic AST?
 *)
type ast = 
  (* generic, which is used currently for: 
   * - Rust
   * - TODO Ruby
   * - Jsonnet
   * - Yaml
   * - TODO Bash 
   * - TODO Docker
   * - Lisp/Scheme/Clojure/Sexp (but currently use Raw_tree so no
   *   great highlighting for now)
  *)
  | Generic of (AST_generic.program * (Tok.t * Parse_languages.origin_info) list)
(* old: was just lexer in old pfff
  | Csharp of Parse_csharp.program_and_tokens
  | Hs  of Parse_hs.program_and_tokens
  | Erlang of Parse_erlang.program_and_tokens
*)

  (* functional *)
  | ML  of (AST_ocaml.program, Parser_ml.token) Parsing_result.t
  | Scala of (AST_scala.program, Parser_scala.token) Parsing_result.t

  (* web *)
  | Html of Parse_html.program_and_tokens
  | Js  of (Ast_js.a_program, Parser_js.token) Parsing_result.t
  | Php of (Cst_php.program, Parser_php.token) Parsing_result.t

  (* system *)
  | Cpp of (Ast_cpp.program, Parser_cpp.token) Parsing_result.t
  | Go of (Ast_go.program, Parser_go.token) Parsing_result.t

  (* mainstream *)
  | Java of (Ast_java.program, Parser_java.token) Parsing_result.t

  (* scripting *)
  | Python of (AST_python.program, Parser_python.token) Parsing_result.t

  (* documentation *)
  | Noweb of Parse_nw.program_and_tokens
  (* less? | Org of Org_mode.org ? *)

let _hmemo_file = Hashtbl.create 101

(* with directories with many files, this is useful *)
let parse_cache parse_in extract (file : Fpath.t) =
  Profiling.profile_code "View.parse_cache" (fun () ->
    let mtime = UFile.filemtime file in
    let recompute = 
      if Hashtbl.mem _hmemo_file file
      then
        let (oldmtime, _ast) = Hashtbl.find _hmemo_file file in
        mtime > oldmtime
      else true
    in
    let ast =
      if recompute
      then begin
        let ast = parse_in file in
        Hashtbl.replace _hmemo_file file (mtime, ast);
        ast
      end
      else Hashtbl.find _hmemo_file file |> snd
    in
    extract ast
  )
(*****************************************************************************)
(* Semantic ehancement *)
(*****************************************************************************)

let use_arity_of_use_count n =
  match () with
  (* note that because my PHP object analysis have some threshold
   * on the number of callers (see threshold_callers_indirect_db)
   * the number for HugeUse can not be more than this one otherwise
   * you will miss some cases
   *)
  | _ when n >= 100 -> HugeUse
  | _ when n > 20   -> LotsOfUse
  | _ when n >= 10  -> MultiUse
  | _ when n >= 2   -> SomeUse
  | _ when n =|= 1    -> UniqueUse
  | _               -> NoUse

let rewrite_categ_using_entities s categ file entities =
  match Db.entity_kind_of_highlight_category_def categ with
  | None -> categ
  | Some e_kind ->

    let entities = 
      Hashtbl.find_all entities s |> List.filter (fun e ->
        (* we could have the full www dbcode but run the treemap on
         * a subdir in which case the root will not be the same.
         * It's a good approximation to just look at the basename.
         * The only false positive we will get if another file,
         * with the same name happened to also define entities
         * with the same name, which would be rare.
         * 
         * update: TODO use Model2.readable_to_absolute_filename_under_root ?
         *)
        Filename.basename e.Db.e_file = Filename.basename file &&
        (* some file have both a function and class with the same name *)
        Database_code.matching_def_short_kind_kind e_kind e.Db.e_kind 
      )
    in
    match entities with
      | [] -> categ
      | [e] ->
          let use_cnt = e.Db.e_number_external_users in
          let arity = use_arity_of_use_count use_cnt in
          if Database_code.is_entity_def_category categ
          then HC.rewrap_arity_def2_category arity categ 
          else categ
      | _x::_y::_xs ->
        (* TODO: handle __construct directly *)
        if not (List.mem s ["__construct"])
        then Logs.warn (fun m -> m "multi def found for %s in %s" s file);
        categ

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

let tokens_with_categ_of_file_helper 
  {PH.parse; highlight; info_of_tok} (file : string) prefs hentities =
  
  Logs.info (fun m -> m "Parsing: %s" file);
  let (ast, toks) = parse (Fpath.v file) in

  Logs.info (fun m -> m "Highlighting: %s" file);
    let h = Hashtbl.create 101 in

    (* computing the token attributes *)
    highlight ~tag_hook:(fun info categ -> Hashtbl.add h info categ)
      prefs (Fpath.v file) (ast, toks);

    (* getting the text *)
    toks |> List_.filter_map (fun tok -> 
      let info = info_of_tok tok in
      let s = Tok.content_of_tok info in
      if not (Tok.is_origintok info)
      then None
      else 
        let categ = Common2_.hfind_option info h |> Option.map (fun categ ->
          rewrite_categ_using_entities s categ file hentities
        ) in
        Some (s, categ,{ Pos.l = Tok.line_of_tok info; c = Tok.col_of_tok info; })
    )

(*****************************************************************************)
(* Main entry point *)
(*****************************************************************************)

(* coupling: right now if you add a language here, you need to whitelist it
 * also in Draw_microlevel.draw_contents2.
 *)
let tokens_with_categ_of_file (file : string) hentities = 
  let ftype = FT.of_file (Fpath.v file) in
  let prefs = Highlight_code.default_highlighter_preferences in
  
  match ftype with
  (* currently abusing the OCaml parser to also parse ATD files
   * TODO? works also for Fsharp; at least the tokenizer 
   *)
  | FT.PL (FT.OCaml _) | FT.PL (FT.IDL FT.ATD) ->
      tokens_with_categ_of_file_helper 
        { parse = (parse_cache (fun file -> 
             ML (Parse_languages.parse_ocaml file)
         )
         (function 
         | ML {Parsing_result. ast; tokens; _} -> (ast, tokens)
         | _ -> raise Impossible));
        highlight = (fun ~tag_hook prefs file (ast, toks) -> 
          Highlight_ml.visit_program ~tag_hook prefs file (ast, toks));
        info_of_tok = Token_helpers_ml.info_of_tok;
        }
        file prefs hentities
  | FT.PL (FT.Web (FT.Php _)) ->
      tokens_with_categ_of_file_helper 
        { parse = (parse_cache (fun file ->
          Common.save_excursion Flag_parsing.error_recovery true (fun () ->
            (* todo: use database_light if given? we could so that
             * variables are better annotated.
             * note that database_light will be passed in
             * rewrite_categ_using_entities() at least.
             *)
(*
            let find_entity = None in
            (* work by side effect on ast2 too *)
            (try 
            Check_variables_php.check_and_annotate_program
              find_entity
              ast
             with Cst_php.TodoNamespace _ | Common.Impossible -> ()
            );
*)
            Php (Parse_php.parse file)
          ))
         (function  
          | Php {Parsing_result. ast; tokens; _} -> (ast, tokens)
          | _ -> raise Impossible));
         highlight = (fun ~tag_hook prefs _file (ast, toks) ->
          Highlight_php.visit_program ~tag:tag_hook prefs hentities 
            (ast, toks)
         );
         info_of_tok = Token_helpers_php.info_of_tok;
        }
        file prefs hentities

  | FT.PL (FT.Scala) ->
      tokens_with_categ_of_file_helper 
        { parse = (parse_cache (fun file -> 
           Common.save_excursion Flag_parsing.error_recovery true (fun()->
             Scala (Parse_scala.parse file)
         ))
         (function 
         | Scala {Parsing_result. ast; tokens; _} -> (ast, tokens)
         | _ -> raise Impossible));
        highlight = (fun ~tag_hook prefs file (ast, toks) -> 
          Highlight_scala.visit_program ~tag_hook prefs file (ast, toks));
        info_of_tok = Token_helpers_scala.info_of_tok;
        }
        file prefs hentities

  | FT.PL (FT.Python) ->
      tokens_with_categ_of_file_helper 
        { parse = (parse_cache (fun file -> 
           Common.save_excursion Flag_parsing.error_recovery true (fun()->
             Python (Parse_python.parse file))
         )
         (function 
         | Python {Parsing_result. ast; tokens; _} -> (Some ast, tokens)
         | _ -> raise Impossible
         ));
        highlight = (fun ~tag_hook prefs _file (ast, toks) -> 
          Highlight_python.visit_program ~tag_hook prefs (ast, toks));
        info_of_tok = Token_helpers_python.info_of_tok;
        }
        file prefs hentities

  | FT.PL (FT.Rust) ->
      let ph_with_cache = 
        { PH.rust with parse = (parse_cache 
              (fun file -> Generic (PH.rust.parse file))
              (function Generic (ast, toks) -> ast, toks | _ -> raise Impossible))} in
      tokens_with_categ_of_file_helper ph_with_cache
        file prefs hentities
(* TODO
  | FT.PL (FT.Ruby) ->
      let ph_with_cache = 
        { PH.ruby with parse = (parse_cache 
              (fun file -> Generic (PH.ruby.parse file))
              (function Generic (ast, toks) -> ast, toks | _ -> raise Impossible))} in
      tokens_with_categ_of_file_helper ph_with_cache
        file prefs hentities
 *)

  | FT.Config (FT.Jsonnet) ->
      let ph_with_cache = 
        { PH.jsonnet with parse = (parse_cache 
              (fun file -> Generic (PH.jsonnet.parse file))
              (function Generic (ast, toks) -> ast, toks | _ -> raise Impossible))} in
      tokens_with_categ_of_file_helper ph_with_cache
        file prefs hentities

  | FT.Config (FT.Yaml) ->
      let ph_with_cache = 
        { PH.yaml with parse = (parse_cache 
              (fun file -> Generic (PH.yaml.parse file))
              (function Generic (ast, toks) -> ast, toks | _ -> raise Impossible))} in
      tokens_with_categ_of_file_helper ph_with_cache
        file prefs hentities

  | FT.Config (FT.Dockerfile) ->
      let ph_with_cache = 
        { PH.dockerfile with parse = (parse_cache 
              (fun file -> Generic (PH.dockerfile.parse file))
              (function Generic (ast, toks) -> ast, toks | _ -> raise Impossible))} in
      tokens_with_categ_of_file_helper ph_with_cache
        file prefs hentities

  | FT.PL (FT.Lisp _) | FT.Config (FT.Sexp) ->
      let ph_with_cache = 
        { PH.lisp with parse = (parse_cache 
              (fun file -> Generic (PH.lisp.parse file))
              (function Generic (ast, toks) -> ast, toks | _ -> raise Impossible))} in
      tokens_with_categ_of_file_helper ph_with_cache
        file prefs hentities

  | FT.PL (FT.Script _) ->
      let ph_with_cache = 
        { PH.bash with parse = (parse_cache 
              (fun file -> Generic (PH.bash.parse file))
              (function Generic (ast, toks) -> ast, toks | _ -> raise Impossible))} in
      tokens_with_categ_of_file_helper ph_with_cache
        file prefs hentities

(*
  | FT.PL (FT.Csharp) ->
      tokens_with_categ_of_file_helper 
        { parse = (parse_cache 
         (fun file -> Csharp (Parse_csharp.parse file |> fst))
         (function Csharp (ast, toks) -> [ast, toks] | _ -> raise Impossible));
        highlight = (fun ~tag_hook prefs (ast, toks) -> 
          Highlight_csharp.visit_program ~tag_hook prefs (ast, toks));
        info_of_tok = Token_helpers_csharp.info_of_tok;
        }
        file prefs hentities

  | FT.PL (FT.Haskell _) ->
      tokens_with_categ_of_file_helper 
        { parse = (parse_cache 
         (fun file -> Hs (Parse_hs.parse file |> fst))
         (function Hs (ast, toks) -> [ast, toks] | _ -> raise Impossible));
        highlight = (fun ~tag_hook prefs (ast, toks) -> 
          Highlight_hs.visit_program ~tag_hook prefs (ast, toks));
        info_of_tok = Parser_hs.info_of_tok;
        }
        file prefs hentities

  | FT.PL (FT.Erlang) ->
      tokens_with_categ_of_file_helper 
        { parse = (parse_cache 
         (fun file -> Erlang (Parse_erlang.parse file |> fst))
         (function Erlang x -> [x] | _ -> raise Impossible));
        highlight = Highlight_erlang.visit_program;
        info_of_tok = Token_helpers_erlang.info_of_tok;
        }
        file prefs hentities
 *)
  | FT.PL (FT.Java) ->
      tokens_with_categ_of_file_helper 
        { parse = (parse_cache 
         (fun file -> Java (Parse_java.parse file))
          (function 
          | Java {Parsing_result. ast; tokens; _} -> (ast, tokens)
          | _ -> raise Impossible));
        highlight = Highlight_java.visit_toplevel;
        info_of_tok = Token_helpers_java.info_of_tok;
        }
        file prefs hentities

  | FT.PL (FT.Cplusplus _ | FT.C _ | FT.ObjectiveC _)
  (* TODO? for Protobuf we could now use the one in tree-sitter
   * TODO: does not work yet because got a Failure ("not a C/C++ file ...")
   *)  
  | FT.PL (FT.IDL (FT.Thrift | FT.Protobuf))
     ->
      tokens_with_categ_of_file_helper 
        { parse = (parse_cache 
         (fun file -> 
          Common.save_excursion Flag_parsing.error_recovery true (fun () ->
           (* work by side effect on ast2 too *)
(* TODO? or Naming_AST.ml now better anyway?
           Check_variables_cpp.check_and_annotate_program
             ast;
*)
           Cpp (Parse_cpp.parse file)
         ))
         
         (function 
         | Cpp {Parsing_result. ast; tokens; _} -> (ast, tokens)
         | _ -> raise Impossible));
        highlight = Highlight_cpp.visit_toplevel;
        info_of_tok = Token_helpers_cpp.info_of_tok;
        }
        file prefs hentities

  | FT.PL (FT.Go) ->
      tokens_with_categ_of_file_helper 
        { parse = (parse_cache 
         (fun file -> Go (Parse_go.parse file))
          (function 
          | Go {Parsing_result. ast; tokens; _} -> (ast, tokens)
          | _ -> raise Impossible));
        highlight = Highlight_go.visit_program;
        info_of_tok = Token_helpers_go.info_of_tok;
        }
        file prefs hentities

  | FT.Text ("nw" | "tex" | "texi" | "web") ->
      tokens_with_categ_of_file_helper 
        { parse = (parse_cache 
         (fun file -> Noweb (Parse_nw.parse file |> fst))
         (function Noweb x -> x | _ -> raise Impossible));
        highlight = Highlight_nw.visit_program;
        info_of_tok = Token_helpers_nw.info_of_tok;
        }
        file prefs hentities


  | FT.PL (FT.Web (FT.Js | FT.Coffee | FT.TypeScript)) ->
      tokens_with_categ_of_file_helper 
        { parse = (parse_cache
          (fun file -> 
            Common.save_excursion Flag_parsing.error_recovery true (fun () ->
              Js (Parse_js.parse file))
          )
         (function 
         | Js {Parsing_result. ast; tokens; _} -> ast, tokens
         | _ -> raise Impossible
         ));
        highlight = Highlight_js.visit_program;
(* TODO?
          let s = Token_helpers_js.str_of_tok tok in
          Ast_js.remove_quotes_if_present s
*)
        info_of_tok = Token_helpers_js.info_of_tok;
        }
        file prefs hentities

  | FT.PL (FT.Web (FT.Html)) ->
      tokens_with_categ_of_file_helper 
        { parse = (parse_cache 
          (fun file -> Html (Parse_html.parse file))
          (function 
          | Html (ast, toks) -> ast, toks
          | _ -> raise Impossible));
        highlight = Highlight_html.visit_toplevel;
        info_of_tok = Token_helpers_html.info_of_tok;
        }
        file prefs hentities

  | FT.Text ("org") ->
      let org = Org_mode.parse file in
      Org_mode.highlight org

  (* ugly, hardcoded, should instead look at the head of the file for a
   * # -*- org   indication.
   * very pad and code-overlay specific.
   *)
  | FT.Text ("txt") when Filename.basename file = "info.txt" ->
      let org = Org_mode.parse file in
      Org_mode.highlight org

  | _ -> failwith 
      "impossible: should be called only when file has good file_kind"
@ 



\section{OCaml}

\section{Tex/Latex/NoWeb}



\section{PHP}

\section{Javascript}

\section{[[C/C++]] and variants}
%variants: thrift

\section{Haskell}

\section{Lisp/Scheme}

\chapter{Optimisations}

\section{Threads, Idle, Timeouts}

<<type async>>=
type 'a t = {
  m: Mutex.t; 
  c: Condition.t;
  v: 'a option ref;
  }
@ 

<<async functions sig>>=
val async_make: unit -> 'a t
val async_get: 'a t -> 'a
val async_set: 'a -> 'a t -> unit
val async_ready: 'a t -> bool
val async_get_opt: 'a t -> 'a option

val with_lock: (unit -> 'a) -> Mutex.t -> 'a
@

<<async functions>>=
let async_make () = {
  m = Mutex.create (); 
  c = Condition.create ();
  v = ref None;
}

let with_lock f l =
  Mutex.lock l;
  try 
    let x = f () in 
    Mutex.unlock l; 
    x
  with e -> 
    Mutex.unlock l; 
    raise e

let async_get a = 
  let rec go a =
    match !(a.v) with
    | None -> 
        UCommon.pr2 "not yet computed";
        Condition.wait a.c a.m; 
        go a
    | Some v -> v
  in
  with_lock (fun () -> go a) a.m

let async_set v a = 
  with_lock (fun () ->
    a.v := Some v;
    Condition.signal a.c;
  ) a.m

let async_ready a = 
  (* actually I don't think you need the lock *)
  with_lock (fun () ->
    match !(a.v) with
    | Some _ -> true
    | None -> false
  ) a.m

let async_get_opt a =
  if async_ready a
  then Some (async_get a)
  else None

@ 

\chapter{Configuration}

<<options>>=
  "-screen_size", Arg.Set_int screen_size,
  " <int> (1 = small, 2 = big)";
  "-legend", Arg.Set legend,
  " display the legend";
  "-no_legend", Arg.Clear legend,
  " do not display the legend";

  "-symlinks", Arg.Unit (fun () -> Treemap.follow_symlinks := true;),
  " follow symlinks";
  "-no_symlinks", Arg.Unit (fun () -> Treemap.follow_symlinks := false),
  " do not follow symlinks";

  "-with_graph", Arg.String (fun s -> graph_file := Some s),
  " <graph_file> dependency semantic information";
  "-with_db", Arg.String (fun s -> db_file := Some s),
  " <db_file> generic semantic information";
  "-with_layer", Arg.String (fun s -> layer_file := Some s),
  " <layer_file>";
  "-with_layers", Arg.String (fun s -> layer_dir := Some s),
  " <dir_with_layers>";
  "-filter", Arg.String (fun s -> filter := List.assoc s filters;), 
   spf " filter certain files (available = %s)" 
    (filters |> List.map fst |> String.concat ", ");
  "-extra_filter", Arg.String (fun s -> Flag.extra_filter := Some s),
  " ";

  "-ft", Arg.Set_float Flag.threshold_draw_content_font_size_real,
  " <float> threshold to draw content";
  "-nblines_file", Arg.Set_float Flag.threshold_draw_content_nblines,
  " <float>";
  "-boost_lbl", Arg.Set Flag.boost_label_size,
  " boost size of labels";
  "-emacs_client", Arg.Set_string Editor_connection.emacsclient_path,
  " <path>";
  "-efuns_client", Arg.Set_string Editor_connection.efunsclient_path,
  " <path>";

(*-------------------------------------------------------------------------*)
(* debugging helpers *)
(*-------------------------------------------------------------------------*)

  "-verbose", Arg.Unit (fun () -> logs_level := Some Logs.Info),
  " ";
  "-debug", Arg.Unit (fun () -> logs_level := Some Logs.Debug),
  " ";
  "-quiet", Arg.Unit (fun () -> logs_level := None),
  " ";
  "-debug_handlers", Arg.Set Gui.synchronous_actions,
  " ";
  "-disable_fonts", Arg.Set Flag.disable_fonts,
  " ";

  "-test", Arg.String (fun s -> test_mode := Some s),
  " <str> execute an internal script";
@

<<type settings>>=
@

<<Style.mli>>=

val windows_params : int -> int * int * int * int

val size_font_multiplier_of_categ :
  font_size_real:float -> Highlight_code.category option -> float

val threshold_draw_dark_background_font_size_real : float

val zoom_factor_incruste_mode : float

val font_size_filename_cursor: float

val font_text: string

@ 

<<[[windows_params]]()>>=
let windows_params screen_size =
  let width, height, minimap_hpos, minimap_vpos = 
    match screen_size with
    | 1 ->
        1350, 800, 1100, 150
    (* on Apple Thunderbolt 27' display *)
    | 2 ->
        2560, 1580, 2350, 100 (* was 2200 and 280 *)
    (* on Dell 40' *)
    | 3 ->
       (* on LG 38' display with split codemap/efuns *)
       (* 2510, 1540, 0, 0 *)
       (* TODO: would like to put more, like 3400x2000 but does not work
        * and it instead maximize the window (gnome/mutter bug?)
        *)
       2700, 1600, 0, 0
       
    | 4 ->
        16000, 9000, 15900, 100
    | 5 ->
        20000, 12000, 19900, 100
    | 6 ->
        25000, 15000, 24900, 100
    | _ ->
        failwith "not valid screen_size"
  in
  width, height, minimap_hpos, minimap_vpos
@


<<[[size_font_multiplier_of_categ]]()>>=
let multiplier_use x = 
  match x with
  | HC.HugeUse -> 3.3
  | HC.LotsOfUse -> 2.7
  | HC.MultiUse -> 2.1
  | HC.SomeUse -> 1.7
  | HC.UniqueUse -> 1.3
  | HC.NoUse -> 0.9

let size_font_multiplier_of_categ ~font_size_real categ =
  match categ with
  | None -> 1.
  | Some x ->
    (match x with
    (* entities defs *)

    | HC.Entity (E.Module, (HC.Def2 use))   -> 5. *. multiplier_use use
    | HC.Entity (E.Package, (HC.Def2 use))   -> 5. *. multiplier_use use
    | HC.Entity (E.Type, (HC.Def2 use))     -> 5. *. multiplier_use use
    | HC.Entity (E.Class, (HC.Def2 use))    -> 5. *. multiplier_use use

    | HC.Entity (E.Function, (HC.Def2 use)) -> 3.5 *. multiplier_use use
    | HC.Entity (E.Method, (HC.Def2 use))   -> 3.5 *. multiplier_use use
    | HC.Entity (E.Global, (HC.Def2 use))   -> 3. *. multiplier_use use

    | HC.Entity (E.Constant, (HC.Def2 use)) -> 2. *. multiplier_use use
    | HC.Entity (E.Exception, (HC.Def2 use))    -> 2. *. multiplier_use use
    | HC.Entity (E.Macro, (HC.Def2 use))    -> 2. *. multiplier_use use
    | HC.Entity (E.Field, (HC.Def2 use))    -> 1.7 *. multiplier_use use
    | HC.Entity (E.Constructor, (HC.Def2 use)) -> 1.2 *. multiplier_use use

    | HC.FunctionDecl use -> 2.5 *. multiplier_use use
    | HC.StaticMethod (HC.Def2 use) -> 3.5 *. multiplier_use use
    | HC.StructName (HC.Def) -> 3.

    | HC.GrammarRule -> 2.5
        
    (* entities uses *)
    | HC.Entity (E.Global, (HC.Use2 _)) when font_size_real > 7.
          -> 1.5

    (* | HC.Method (HC.Use2 _) when font_size_real > 7.  -> 1.2 *)
        
    (* "literate programming" *)
    | HC.CommentSection0 -> 5.
    | HC.CommentSection1 -> 3.
    | HC.CommentSection2 -> 2.0
    | HC.CommentSection3 -> 1.2
    | HC.CommentSection4 -> 1.1
    | HC.CommentEstet -> 1.0
    | HC.CommentCopyright -> 0.5

    | HC.CommentSyncweb -> 1.

 (* | HC.Comment when font_size_real > 7. -> 1.5 *)

    (* semantic visual feedback *)

    | HC.BadSmell -> 2.5

    (* ocaml *)
    | HC.UseOfRef -> 2.

    (* php, C, etc *)
    | HC.PointerCall -> 5.
    | HC.ParameterRef -> 2.
    | HC.CallByRef -> 3.

    (* misc *)
    | HC.Local (HC.Def) -> 1.2
        
    | _ -> 
        (* the cases above should have covered all the cases *)
        if Database_code.is_entity_def_category x
        then failwith "You should update size_font_multiplier_of_categ";

        1. 
    )
@


<<[[zoom_factor_incruste_mode]]>>=
(* TODO: should be automatically computed. Should have instead a
 * wanted_real_font_size_when_incruste_mode = 9.
 *)
let zoom_factor_incruste_mode = 10. (* was 18 *)
@


<<[[threshold_draw_dark_background_font_size_real]]>>=
(* CONFIG *)
let threshold_draw_dark_background_font_size_real = 5.
@


<<src/gui/flag_visual.ml>>=

(* It was 0.4, but on Linux the anti-aliasing seems to not be as good
 * as on Mac (possibly because I have only an old cairo lib on my 
 * Linux machine). 
 * I've recently raised this number because
 * when too low it's just too much noise on the screen.
 * Let's draw the content when you can actually read things and
 * when things don't overlap too much.
 *)
let threshold_draw_content_font_size_real = ref 
  2.5

(* big and auto-generated files can take too much time to render *)
let threshold_draw_content_nblines = 
  ref 25000.

let threshold_draw_label_font_size_real = ref 
  10.

let threshold_nb_rects_draw_content = ref 2500

let threshold_too_many_entities = ref 600000

let top_n = ref 100

let boost_label_size = ref false

let disable_fonts = ref false

let extra_filter = ref (None: string option) (* regexp *)
@ 


\chapter{Other Features}

<<[[visual_commitid]]() action>>=
let test_visual_commitid id =
  let files = UCmd.cmd_to_list
    (spf "git show --pretty=\"format:\" --name-only %s"
        id) 
    (* not sure why git adds an extra empty line at the beginning but we
     * have to filter it
     *)
    |> List_.exclude String_.empty
  in
  UCommon.pr2_gen files;
  main_action files
@

<<actions>>=
  "-test_loc", " ",
  Arg_.mk_action_n_arg (test_loc true);
  "-test_loc2", " ",
  Arg_.mk_action_n_arg (test_loc false);
  "-test_cairo", " ",
  Arg_.mk_action_0_arg (test_cairo);
  "-test_commitid", " <id>",
  Arg_.mk_action_1_arg (test_visual_commitid);
  "-test_treemap_dirs", " <id>",
  Arg_.mk_action_0_arg (test_treemap_dirs);
@



\chapter{Related Work}

\begin{verbatim}

http://www.haskell.org/haskellwiki/Yi

http://www.cse.chalmers.se/~bernardy/FunctionalIncrementalParsing.pdf
"Thanks for the links. The paper is a very interesting reading indeed.
Its main focus is on incrementality (not reparsing the whole buffer at
every keystroke). I'm not so sure how important it is in the context
of the current discussion though: I guess that with an efficient
parsing technology and modern computers, parsing even a big buffer at
every keystroke should be fast enough. Trivial optimizations like
storing the internal state of the parser at some point could also be
used if needed. I'm more concerned about the error recovery aspect;
the paper suggests the use of annotated error recovery rules, but
writing them for a grammar like OCaml's does not seem an easy task at
all." - frish

\end{verbatim}

\chapter{Conclusion}

Hope you like it.


\appendix

\chapter{Gtk}

\chapter{Cairo}

% ref to good tutorial

<<[[new_pixmap]] sig>>=
val new_surface: 
  alpha:bool -> width:int -> height:int -> Cairo.Surface.t
@

<<[[new_pixmap]]()>>=
let new_surface ~alpha ~width ~height =
  let drawable = GDraw.pixmap ~width:1 ~height:1 () in
  drawable#set_foreground `WHITE;
  drawable#rectangle ~x:0 ~y:0 ~width:1 ~height:1 ~filled:true ();


  let cr = Cairo_gtk.create drawable#pixmap in
  let surface = Cairo.get_target cr in
  Cairo.Surface.create_similar surface
    (if alpha 
    then Cairo.COLOR_ALPHA
    else Cairo.COLOR
    ) width height


@

<<cairo helpers functions sig>>=
val fill_rectangle:
  ?alpha:float ->
  cr:Cairo.context -> 
  x:float -> y:float -> w:float -> h:float ->
  color:Simple_color.emacs_color -> 
  unit ->
  unit

val draw_rectangle_figure:
  cr:Cairo.context -> 
  color:Simple_color.emacs_color -> 
  Figures.rectangle -> unit

val draw_rectangle_bis:
  cr:Cairo.context -> 
  color:Simple_color.color -> 
  line_width:float ->
  Figures.rectangle -> unit


val prepare_string : string -> string
val origin : Figures.point

val device_to_user_distance_x : Cairo.context -> float -> float
val device_to_user_distance_y : Cairo.context -> float -> float
val user_to_device_distance_x : Cairo.context -> float -> float
val user_to_device_distance_y : Cairo.context -> float -> float

val device_to_user_size : Cairo.context -> float -> float
val user_to_device_font_size : Cairo.context -> float -> float
val cairo_point_to_point : float * float -> Figures.point

val show_text : Cairo.context -> string -> unit
val text_extents : Cairo.context -> string -> Cairo.text_extents
val set_font_size: Cairo.context -> float -> unit

val clear : Cairo.context -> unit

val surface_of_pixmap :
  < pixmap : [> `drawable ] Gobject.obj; .. > -> Cairo.Surface.t

val distance_points : Figures.point -> Figures.point -> float

@

<<cairo helpers functions>>=
let prepare_string s = 
  let buf = Bytes.of_string s in
(*  if s ==~ re_space then  s ^ s (* double it *) else  *)
  for i = 0 to String.length s -.. 1 do
    let c = String.get s i in
    let final_c =
      match c with
      | _ when int_of_char c >= 128 -> 'Z'
      | '\t'-> ' '
      | _ -> c
    in
    Bytes.set buf i final_c
  done;
  Bytes.to_string buf

(* TODO: fast enough with those of_string and to_string? *)
let show_text cr s =
  try 
    let s = prepare_string s in
    Cairo.show_text cr s
  with Cairo.Error status ->
    let s2 = Cairo.status_to_string status in
    failwith ("Cairo pb: " ^ s2 ^ " s = " ^ s)
[@@profiling]

(*
let fake_text_extents = 
  { Cairo.
    x_bearing   = 0.1; y_bearing   = 0.1;
    text_width  = 0.1; text_height = 0.1;
    x_advance   = 0.1; y_advance   = 0.1 ;
  }
*)

let text_extents cr s = 
  Profiling.profile_code "CairoH.cairo_text_extent" (fun () -> 
    (*if s = ""  then fake_text_extents else *)
    Cairo.text_extents cr s
  )

(* just wrap it here so that we can profile it *)
let set_font_size cr font_size =
  Profiling.profile_code "CairoH.set_font_size" (fun () ->
    Cairo.set_font_size cr font_size
  )

(*****************************************************************************)
(* Distance conversion *)
(*****************************************************************************)

let origin = { Figures. x = 0.; y = 0. }

let device_to_user_distance_x cr deltax = 
  let (x, _) = Cairo.device_to_user_distance cr deltax 0. in
  x
let device_to_user_distance_y cr deltay = 
  let (_, y) = Cairo.device_to_user_distance cr 0. deltay in
  y

let user_to_device_distance_x cr deltax = 
  let (x, _) = Cairo.user_to_device_distance cr deltax 0. in
  x
let user_to_device_distance_y cr deltay = 
  let (_, y) = Cairo.user_to_device_distance cr 0. deltay in
  y

(* TODO: this is buggy, as we can move the map which can led to
 * some device_to_user to translate to x = 0
 *)
let device_to_user_size cr size = 
  let (x, _) = Cairo.device_to_user cr size 0. in
  x

(* less: just call device_to_user_size ? *)
let user_to_device_font_size cr font_size = 
  let (x, _) = Cairo.user_to_device_distance cr font_size font_size in
  x

let cairo_point_to_point (x, y) = { F.x; y }

let distance_points p1 p2 =
  abs_float (p2.Figures.x - p1.Figures.x) + 
  abs_float (p2.Figures.y - p1.Figures.y)

(*****************************************************************************)
(* Surface *)
(*****************************************************************************)

(* see http://cairographics.org/FAQ/#clear_a_surface *)
let clear cr =
  Cairo.set_source_rgba cr 0. 0. 0.   0.;
  Cairo.set_operator cr Cairo.SOURCE;
  Cairo.paint cr;
  Cairo.set_operator cr Cairo.OVER;
  ()

let surface_of_pixmap pm =
  let cr = Cairo_gtk.create pm#pixmap in
  Cairo.get_target cr

(*****************************************************************************)
(* Drawing *)
(*****************************************************************************)

let fill_rectangle ?(alpha=1.) ~cr ~x ~y ~w ~h ~color () = 
  (let (r,g,b) = color |> Color.rgbf_of_string in
  Cairo.set_source_rgba cr r g b alpha;
  );
  
  Cairo.move_to cr x y;
  Cairo.line_to cr (x+w) y;
  Cairo.line_to cr (x+w) (y+h);
  Cairo.line_to cr x (y+h);
  Cairo.fill cr;
  ()

let draw_rectangle_figure ~cr ~color r =
  (let (r,g,b) = color |> Color.rgbf_of_string in
  Cairo.set_source_rgb cr r g b;
  );
 let line_width = device_to_user_size cr 3. in

  Cairo.set_line_width cr line_width; (* ((r.q.y - r.p.y) / 30.); *)

  Cairo.move_to cr r.p.x r.p.y;
  Cairo.line_to cr r.q.x r.p.y;
  Cairo.line_to cr r.q.x r.q.y;
  Cairo.line_to cr r.p.x r.q.y;
  Cairo.line_to cr r.p.x r.p.y;
  Cairo.stroke cr;
  ()

(* factorize with draw_rectangle. don't use buggy device_to_user_size !!!
*)
let draw_rectangle_bis ~cr ~color ~line_width r =
  (let (r,g,b) = 
    color |> Color.rgb_of_color |> Color.rgbf_of_rgb
    in
   Cairo.set_source_rgb cr r g b;
  );
  Cairo.set_line_width cr line_width;

  Cairo.move_to cr r.p.x r.p.y;
  Cairo.line_to cr r.q.x r.p.y;
  Cairo.line_to cr r.q.x r.q.y;
  Cairo.line_to cr r.p.x r.q.y;
  Cairo.line_to cr r.p.x r.p.y;
  Cairo.stroke cr;
  ()
@

\paragraph{User vs device coordinates}





\chapter{Extra Code}

% for make index; make pdf
<<languages/nw/ast_nw.ml>>=
@
<<languages/html/ast_html.ml>>=
@
<<src/program_visual/flag_program_visual.ml>>=
@
<<libs/gui/Gui.ml>>=
@

\section{[[Main.ml]]}

<<src/main/Main.ml>>=
(*
 * Please imagine a long and boring gnu-style copyright notice 
 * appearing just here.
 *)
open Common
open Fpath_.Operators
module Flag = Flag_visual
module FT = Ftype

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* This is the main entry point of codemap, a semantic source code visualizer
 * using treemaps and code thumbnails. The focus here is code understanding
 * not editing, so for instance even if features like autocompletion are
 * great for editing, they are not really helpful for understanding an existing
 * codebase. What can help is completion to help navigate and go from one
 * place to another, and this is one of the feature of this tool.
 * 
 * requirements:
 *  - get a bird's eye view of all the code (hence treemaps)
 *  - get a bird's eye view of a file (hence code thumbnails)
 *  - better syntax highlighting than Emacs, using real parsers so
 *    we can colorize differently identifiers (a function vs a field vs
 *    a constant)
 *  - important code should be bigger. Just like in google maps
 *    the important roads are more visible. So need some sort of
 *    global semantic analysis.
 *  - show the data (the source code), but also show the relations
 *    (hence codegraph integration)
 *  - look at the code through different views (hence layers)
 *  - SEMI deep semantic analysis, control flow + data flow so can answer
 *    flow questions such as where a callback is called (hence datalog)
 * 
 * history:
 *  - saw Aspect Browser while working on aspects as an intern at IRISA
 *  - work on Poffs and idea of visualizing the same code through 
 *    different views
 *  - talked about mixing sgrep/spatch with code visualization,
 *    highlighting with a certain color different architecture aspects
 *    of the Linux kernel (influenced by work on aspect browser)
 *  - talked about fancy code visualizer while at cleanmake with YY,
 *    Spiros, etc.
 *  - saw SeeSoft code visualizer while doing some bibliographic work
 *  - saw code thumbnails by MSR, and Rob Deline
 *  - saw treemap of Linux kernel by Fekete => idea of mixing
 *    tree-map+code-thumbnails+seesoft = codemap
 *  - saw talk at CC'09 about improving javadoc by putting in bigger fonts
 *    really often used API functions => idea of light db and semantic
 *    visual feedback
 *  - read hierarchical edge bundling paper and its d3 implementation to 
 *    visualize on top of a treemap the call graph
 * 
 * related work:
 *  - racket IDE (was called DrScheme before), had arrows long time ago
 *    between occurences of a variable and its definition
 *  - http://peaker.github.io/lamdu/, but focused more on AST pretty printing
 *  - light table, interesting visualization slice but now focused more
 *    on live programming a la Bret Victor
 *  - http://www.kickstarter.com/projects/296054304/zeta-code, mostly focused
 *    on code relations, so related more to codegraph
 *  - textmate, nice fuzzy file find, very quick to go to a place
 *  - sublime, has thumbnails, but people don't really care about it
 *  - http://www.hello2morrow.com/products/sotoarc ?
 *  - http://scg.unibe.ch/codemap ?
 *  - http://scg.unibe.ch/wiki/projects/rbcrawler, class blueprint, very nice
 *    when exploring tangled object code abusing inheritance
 *  - moose http://youtu.be/yvXm9LC17vk at 14min
 *  - http://redotheweb.com/CodeFlower/ ?
 *  - code swarm, visualize git history, focused on people more than code
 *    https://code.google.com/p/gource/ 
 *    http://artzub.com/ghv/#repo=d3&climit=100&user=mbostock
 *  - http://www.codetrails.com/ctrlflow, smarter completion by infering
 *    importance of method (like I do, by #times this entity is globally used)
 *  - codesonar, very nice interactive zoomable call graph visualizer
 *    https://www.youtube.com/watch?v=EqDhtRoorGU also very deep semantic analysis
 *    with control flow and data flow
 *  - CodeCompass https://github.com/Ericsson/CodeCompass/
 *  - Sourcetrail, recently open sourced
 *    https://www.sourcetrail.com/blog/open_source/
 * 
 * features of IDE we do want (e.g. see the list at http://xamarin.com/studio):
 *  - smart syntax highlighting (we do even more: semantic highlighting!)
 *  - go to definition (=~ TAGS, light db and search bar completion provides it)
 *  - code navigation (directory, files, also "hypertext" go to def/uses)
 *  - find uses (funcs, classes, TODO tricky for methods in dynamic languages)
 *  - code tooltip, hover on use of an entity to display information about
 *    it (#uses, TODO: type/args, comments, code, age, methods, etc)
 *  - unified "fuzzy" search (files, entities, TODO but also content),
 *    SEMI project-wide fuzzy search is really useful for filenames but also content!
 *  - debugger? it helps understand code so a coverage layer or TODO live
 *    coverage tracing would be nice (as in tracegl),
 *    also a way to see the actual concrete values of variables/parameters
 *    inline would be nice too (as in intellij 14) (always-on visualization!)
 *  - source control? can extract age, number of authors, churn information in
 *    layers
 *  - SEMI dataflow from here, dataflow to here (intellij)
 * 
 * features of IDE we care less about:
 *  - folding/outline? thumbnails make this less important
 *  - auto completion? One nice thing of autocomplete is that
 *    it proposes all the possible methods of an object, the overriden
 *    as well as not overriden parent methods. We don't need autocomplete
 *    but we want the ability to understand a class by TODO "inlining" parent 
 *    methods that are relevant to understand the local code of the class
 *    (e.g. the short command of Eiffel)
 *  - code snippet? This is similar to auto completion, it's good for writing
 *    new code, but not that useful to understand existing code.
 *  - refactoring? no (but some spatch integration could be nice)
 *  - UI designer? no
 *  - deploy assistant, cloud assistant? no
 *)

(*****************************************************************************)
(* Flags *)
(*****************************************************************************)

<<main flags>>

(* see filters below, which filter files we are interested in *)
let filter = ref (fun _file -> true)
(* less: a config file: GtkMain.Rc.add_default_file "/.../pfff_browser.rc"; *)

(* for -debug, -verbose, -quiet *)
let logs_level = ref (Some Logs.Warning)

(* action mode *)
let action = ref ""

(*****************************************************************************)
(* File targeting *)
(*****************************************************************************)

let filters = [
  (* pad-specific: semgrep related files *)
  "semgrep", (fun file ->
    match FT.of_file file with
    | FT.PL (FT.OCaml _ | FT.Python | FT.Web (FT.Js | FT.TypeScript))
    | FT.PL (FT.IDL _)
    | FT.PL (FT.Script _)
    | FT.Config (FT.Makefile | FT.Dockerfile | FT.Jsonnet | FT.Yaml | FT.Sexp) -> 
            true
    | _ -> false
  );
  (* pad-specific: *)
  "xix", (fun file ->
    match FT.of_file file with
    | FT.PL ((FT.OCaml _) | (FT.C _ | FT.Asm)) | FT.Config FT.Makefile -> true
    | _ -> false
  );

  "ocaml", (fun file ->
    match FT.of_file file with
    | FT.PL (FT.OCaml _) | FT.Config (FT.Makefile)  -> true
    | _ -> false
  );
  "mli", (fun file ->
    match FT.of_file file with
    | FT.PL (FT.OCaml "mli") | FT.Config (FT.Makefile)   -> 
      not (!!file =~ ".*/commons/")
    | _ -> false
  );
  "nw", (fun file -> 
    match FT.of_file file with
    | FT.Text "nw" -> true | _ -> false
  );
  "doc", (fun file -> 
    match FT.of_file file with
    | FT.Text _ -> true | _ -> false
  );

  (* other languages *)
  "php", (fun file ->
    match FT.of_file file with
    | FT.PL (FT.Web (FT.Php _)) -> true  | _ -> false
  );
  "js", (fun file ->
    match FT.of_file file with
    | FT.PL (FT.Web (FT.Js)) -> true  | _ -> false
  );
  "config", (fun file ->
    match FT.of_file file with
    | FT.Config (FT.Yaml | FT.Json) -> true  | _ -> false
  );

  "cpp", (let x = ref false in (fun file ->
    Common2_.once x (fun () -> 
      (* TODO: also add possible pfff_macros.h when there *)
      Parse_cpp.init_defs !Flag_parsing_cpp.macros_h
    );
    match FT.of_file file with
    | FT.PL (FT.C _ | FT.Cplusplus _) -> true 
    | FT.PL FT.Asm -> true
    | _ -> false
  ));

  (* general categories *)
  "pl", (fun file ->
    match FT.of_file file with
    | FT.PL _ -> true  | _ -> false
  );
]

let mk_filter_file (root : Fpath.t) : (Fpath.t -> bool) =
  let gitignore_filter =
    Gitignore_filter.create
      ~gitignore_filenames:[
      Gitignore.{source_kind = "gitignore"; filename = ".gitignore"; format = Gitignore };
      Gitignore.{source_kind = "codemapignore"; filename = ".codemapignore"; format = Gitignore };
      ]
    ~project_root:root ()
  in
  (fun file ->
     !filter file &&
     let ppath =
        match Ppath.in_project ~root:(Rfpath.of_fpath_exn root) (Rfpath.of_fpath_exn file) with
        | Ok ppath -> ppath
        | Error err ->
              failwith (spf "could not find project path for %s with root = %s (errot = %s)"
                !!file !!root err)
     in
     let (status, _events) =
       Gitignore_filter.select gitignore_filter ppath
     in
     status =*= Gitignore.Not_ignored
    )

(*****************************************************************************)
(* Model helpers *)
(*****************************************************************************)

<<[[treemap_generator]]>>

<<function [[build_model]]>>

(* could also to parse all json files and filter the one which do not parse *)
let layers_in_dir dir =
  Common2_.readdir_to_file_list dir |> List_.filter_map (fun file ->
    if file =~ "layer.*json"
    then Some (Filename.concat dir file)
    else None
  )

(*****************************************************************************)
(* Main action *)
(*****************************************************************************)

<<function [[main_action]]>>
  
(*****************************************************************************)
(* Extra actions *)
(*****************************************************************************)

(* related work: http://cloc.sourceforge.net/ but have skip list
 * and archi_code_lexer.mll which lower the important of some files?
 *)
let test_loc print_top30 xs =
  let xs = xs |> List.map Unix.realpath in
  let root = Common2_.common_prefix_of_files_or_dirs xs in

  let filter_file = mk_filter_file (Fpath.v root) in
  let treemap = Treemap_pl.code_treemap ~filter_file xs in

  let res = ref [] in
  let rec aux tree =
    match tree with
    | Common2_.Node (_dir, xs) ->
        List.iter aux xs
    | Common2_.Leaf (leaf, _) ->
        let file = leaf.Treemap.label in
        let size = leaf.Treemap.size in
        let unix_size = (Common2_.unix_stat_eff file).Unix.st_size in
        if unix_size > 0
        then begin
          let multiplier = (float_of_int size /. float_of_int unix_size) in
          let multiplier = min multiplier 1.0 in
          let loc = Common2_.nblines_with_wc file in
          Stack_.push (((Filename_.readable ~root:(root) (file))), 
                       (float_of_int loc *. multiplier)) res;
        end
  in
  aux treemap;
  let total = !res |> List.map snd |> List.map int_of_float  |> Common2_.sum in
  UCommon.pr2 (spf "LOC = %d (%d files)" total (List.length !res));
  if print_top30 then begin
    let topx = 30 in
    UCommon.pr2 (spf "Top %d:" topx);
    !res |> Assoc.sort_by_val_highfirst |> List_.take_safe topx 
    |>  List.iter (fun (file, f) ->
      UCommon.pr2 (spf "%-40s: %d" file (int_of_float f))
    )
  end


let test_treemap_dirs () =
  let paths = 
    ["commons/common.ml"; "h_visualization"; "code_graph"] 
    |> List.map Unix.realpath in
  let paths = List.sort String.compare paths in
  let tree = 
    paths |> Treemap.tree_of_dirs_or_files
      ~filter_dir:Lib_vcs.filter_vcs_dir
      ~filter_file:(fun file -> !!file =~ ".*\\.ml")
      ~file_hook:(fun _file -> 10)
  in
  UCommon.pr2_gen tree


(* update: try to put ocamlgtk related tests in widgets/test_widgets.ml, not
 * here. Here it's for ... well it's for nothing I think because it's not 
 * really easy to test a gui.
 *)

<<[[visual_commitid]]() action>>

let width = 500
let height = 500

let test_draw cr =
  (* [0,0][1,1] world scaled to a width x height screen *)
  Cairo.scale cr (float_of_int width) (float_of_int height);

  Cairo.set_source_rgba cr 0.5 0.5 0.5   0.5;
  Cairo.set_line_width cr 0.001;

  Cairo.move_to cr 0.5 0.5;
  Cairo.line_to cr 0.6 0.6;
  Cairo.stroke cr;

  Cairo.select_font_face cr "serif" ~weight:Cairo.Bold;
  Cairo.set_font_size cr 0.1;
  Cairo.move_to cr 0.1 0.1;
  Cairo.show_text cr "THIS IS SOME TEXT";
  Cairo.move_to cr 0.1 0.2;
  Cairo.show_text cr "THIS IS SOME TEXT";
  Cairo.set_font_size cr 0.05;
  Cairo.move_to cr 0.1 0.3;
  Cairo.show_text cr "THIS IS SOME TEXT";

  Cairo.set_source_rgb cr 0.1 0.1 0.1;
  Cairo.move_to cr 0.1 0.1;
  Cairo.line_to cr 0.1 0.2;
  Cairo.stroke cr;

  let start = ref 0.0 in

  for _i = 0 to 3 do
    let end_ = !start +. 0.5 in
    Cairo.arc cr 0.5 0.5 ~r:0.3 ~a1:!start ~a2:end_;
    Cairo.stroke cr;
    start := end_;
  done;

  ()

let test_cairo () =
  let _locale = GtkMain.Main.init () in
  let w = GWindow.window ~title:"test" () in
  (w#connect#destroy GMain.quit) |> ignore;
  let px = GDraw.pixmap ~width ~height ~window:w () in
  px#set_foreground `WHITE;
  px#rectangle ~x:0 ~y:0 ~width ~height ~filled:true ();
  let cr = Cairo_gtk.create px#pixmap in
  test_draw cr;
  (GMisc.pixmap px ~packing:w#add ()) |> ignore;
  w#show ();
  GMain.main()
  
(*---------------------------------------------------------------------------*)
(* the command line flags *)
(*---------------------------------------------------------------------------*)
let extra_actions () = [
 <<actions>>
]
 
(*****************************************************************************)
(* The options *)
(*****************************************************************************)

let all_actions () = 
 extra_actions()@
 []

let options () = ([ 
  <<options>>
  ] @
  Arg_.options_of_actions action (all_actions()) @
  Common2_.cmdline_flags_devel () @
  [
  "-version",   Arg.Unit (fun () -> 
    UCommon.pr2 (spf "CodeMap version: %s" "TODO: version codemap");
    exit 0;
  ), 
    " guess what";
  ]) |> Arg.align

(*****************************************************************************)
(* The main entry point *)
(*****************************************************************************)
let main () = 

  let usage_msg = 
    spf "Usage: %s [options] <file or dir> \nDoc: %s\nOptions:"
      (Filename.basename Sys.argv.(0))
      "https://github.com/facebook/pfff/wiki/Codemap"
  in
  (* alt: use cmdliner and parse --debug, --info ... *)
  let args = Arg_.parse_options (options()) usage_msg Sys.argv in

  Logs_.setup ~level:!logs_level ();
  Logs.info (fun m -> m "Starting logging");
    
  (* must be done after Arg.parse, because Common.profile is set by it *)
  Profiling.profile_code "Main total" (fun () -> 

    (match args with
    (* --------------------------------------------------------- *)
    (* actions, useful to debug subpart *)
    (* --------------------------------------------------------- *)
    | xs when List.mem !action (Arg_.action_list (all_actions())) -> 
        Arg_.do_action !action xs (all_actions())

    | _ when not (String_.empty !action) -> 
        failwith ("unrecognized action or wrong params: " ^ !action)

    (* --------------------------------------------------------- *)
    (* main entry *)
    (* --------------------------------------------------------- *)
    | (x::xs) -> 
        main_action (x::xs)

    (* --------------------------------------------------------- *)
    (* empty entry *)
    (* --------------------------------------------------------- *)
    | [] -> Arg.usage (options()) usage_msg; 
    );
  )

(*****************************************************************************)
let _ = 
  UCommon.main_boilerplate (fun () ->
    main ()
  )
@ 

\section{[[flag_visual.ml]]}

\section{[[model_graph_code.mli]]}

<<model_graph_code.mli>>=
val build_filedeps_of_dir_or_file: 
  Graph_code.t ->
  (Graph_code.node, string (* filename *) list * string (* filename *) list) Hashtbl.t

(* the nodes are sorted by line numbers *)
val build_entities_of_file:
  Graph_code.t ->
  (string (* filename *), Graph_code.node list) Assoc.t

val add_headers_files_entities_of_file:
  string (* filename *) (* a dir *) -> 
  (string (* filename *), Graph_code.node list) Assoc.t ->
  (string (* filename *), Graph_code.node list) Assoc.t

val node_of_entity: 
  Database_code.entity -> Graph_code.t -> Graph_code.node option
@ 

\section{[[model_database_code.mli]]}

<<model_database_code.mli>>=

<<hentities sig>>

<<[[hfiles_and_top_entities]] sig>>

<<[[all_entities]] sig>>

<<[[actual_root_of_db]] sig>>

<<[[readable_to_absolute_filename_under_root]] sig>>

@ 

\section{[[model_graph_code.ml]]}

<<model_graph_code.ml>>=
<<Facebook copyright>>
open Common
open Fpath_.Operators

module G = Graph_code
module E = Entity_code
module Db = Database_code

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
let is_prefix prefix str =
  (* todo: have better than that? *)
  try 
    String.sub str 0 (String.length prefix) = prefix
  with Invalid_argument _ -> false
  

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

let build_filedeps_of_dir_or_file g =
  (* we use the 'find_all' property of those hashes *)
  let huses = Hashtbl.create 101 in
  let husers = Hashtbl.create 101 in

  let halready = Hashtbl.create 101 in

  g |> G.iter_use_edges (fun n1 n2 ->
    try 
      let file1 = !!(G.file_of_node n1 g) in
      let file2 = !!(G.file_of_node n2 g) in
      (* file to file deps *)
      if file1 <> file2 && not (Hashtbl.mem halready (file1, file2)) then begin
        Hashtbl.replace halready (file1, file2) true;
        Hashtbl.add huses (file1, E.File) file2;
        Hashtbl.add husers (file2, E.File) file1;
      end;
      (* dir to file deps *)
      (* e.g. if a/b/foo.c -> a/c/bar.c then need to add
       * a/b -> a/c/bar.c, but not a/ -> a/c/bar.c cos of is_prefix
       * a/c <- a/b/foo.c, but not a/ <- a/b/foo.c cos of is_prefix
       *)
      let dirs_n1 = Common2_.inits_of_relative_dir file1 in
      let dirs_n2 = Common2_.inits_of_relative_dir file2 in
      dirs_n1 |> List.iter (fun dir ->
        if not (is_prefix dir file2)
        then Hashtbl.add huses (dir, E.Dir) file2;
      );
      dirs_n2 |> List.iter (fun dir ->
        if not (is_prefix dir file1)
        then Hashtbl.add husers (dir, E.Dir) file1;
      );
        
    with Not_found -> ()
  );
  let hres = Hashtbl.create 101 in
  let keys = Common2_.union_set (Common2_.hkeys huses) (Common2_.hkeys husers) in
  keys |> List.iter (fun k ->
    let uses = try Hashtbl.find_all huses k with Not_found -> [] in
    let users = try Hashtbl.find_all husers k with Not_found -> [] in
    (* todo: have to do uniq? if add in hash multiple times with same value,
     * then get multiple bindings?
     *)
    Hashtbl.add hres k (uses, users)
  );
  hres

let build_entities_of_file g =

  (* we use the 'find_all' property of those hashes *)
  let h = Hashtbl.create 101 in

  g |> G.iter_nodes (fun n ->
    try 
      let info = G.nodeinfo n g in
      let file = !!(info.G.pos.pos.file) in
      (* old: let line = info.G.pos.Parse_info.line in *)
      Hashtbl.add h file n;
    with Not_found -> ()
  );
  Common2_.hkeys h |> List.map (fun k ->
    let xs = Hashtbl.find_all h k in
    k, xs
  )

(* Codegraph does not currently handle very well header files. It's because
 * an header contain entities that are considered DUPE of their 
 * corresponding entity in the source file. Right now we skip such 
 * headers (e.g. .mli) in codegraph. The code below is here to
 * adjust codegraph deficiencies by artificially associate the
 * nodes in the source file to also the header file so one can
 * hover a function signature in a .mli and get its uses, users, etc.
 * 
 * ugly: fix that in codegraph instead?
 *)
let add_headers_files_entities_of_file root xs =
  let headers =
    xs |> List_.filter_map (fun (file, xs) ->
      let (d,b,e) = Filename_.dbe_of_filename_noext_ok file in
      match e with
      | "ml" -> 
        let header_readable = Filename_.filename_of_dbe (d,b,"mli") in
        let header = Filename.concat root header_readable in
        if Sys.file_exists header 
        (* todo: we add too many defs here, a mli can actually restrict
         * the set of exported functions, but because we use such
         * information mostly when hovering over entities in a .mli,
         * this should be fine.
         *)
        then Some (header_readable, xs)
        else None
      | _ -> None
    )
  in
  headers @ xs

let node_of_entity e g =
  let fullname = 
    match e.Db.e_fullname with
    | "" -> e.Db.e_name
    | s -> s
  in 
  let node = (fullname, e.Db.e_kind) in
  if G.has_node node g
  then Some node
  else None
@ 

\section{[[model_database_code.ml]]}

<<model_database_code.ml>>=
<<Facebook copyright>>
open Common

module Flag = Flag_visual
module Db = Database_code

(*****************************************************************************)
(* Filenames *)
(*****************************************************************************)

<<[[readable_to_absolute_filename_under_root]]>>

<<[[actual_root_of_db]]>>

(*****************************************************************************)
(* Entities info *)
(*****************************************************************************)

<<hentities()>>

<<[[hfiles_and_top_entities]]()>>

(*****************************************************************************)
(* Completion data *)
(*****************************************************************************)

<<[[all_entities]]>>

@ 

\section{[[Model.mli]]}

<<Model.mli>>=

<<type model>>
and 'a deps = 'a list (* uses *) * 'a list (* users *)


type macrolevel = Treemap.treemap_rendering



type microlevel = {
  point_to_line: Figures.point -> line;
  line_to_rectangle: line -> Figures.rectangle;
  layout: layout;
  container: Treemap.treemap_rectangle;
  (* the lines of the files, 0-based indexed line, see line type below *)
  content: (glyph list) array option;
  (* defs based on highlighters categories *)
  defs: (line * short_node) list;
}
  (* 0-indexed line number, which is different from most tools, but
   * programs prefer 0-based index
   *)
  and line = Line of int

  and layout = {
    lfont_size: float;
    split_nb_columns: float; (* int *)
    width_per_column:float;
    height_per_line: float;
    nblines: float; (* int *)
    nblines_per_column: float; (* int *)
  }

  and glyph = {
    str: string;
    categ: Highlight_code.category option;
    font_size: float;
    color: Simple_color.emacs_color;
    mutable pos: Figures.point;
  }

 (* Note that I don't use G.node because the string below is not fully
  * qualified so one must use match_short_vs_node when comparing with nodes.
  *)
  and short_node = (string * Entity_code.kind)

<<type drawing>>

type world = {
  mutable dw: drawing;
  dw_stack: drawing Stack_.t;

  (* computed lazily, semantic information about the code *)
  model: model Async.t;
  root_orig: string;
  (* to compute a new treemap based on user's action *)
  treemap_func: string (* filename *) list -> Treemap.treemap_rendering;
  (* misc settings, not really used for now *)
  settings: settings;

  mutable current_node: Graph_code.node option;
  mutable current_node_selected: Graph_code.node option;
  mutable current_entity: Database_code.entity option;
}
   and settings = {
     mutable draw_summary: bool;
     mutable draw_searched_rectangles: bool;
   }

<<type context>>
val context_of_drawing: drawing -> model Async.t -> context


<<[[init_drawing]] sig>>

<<[[new_pixmap]] sig>>

(* point -> rectangle -> line -> glyph -> entity *)

<<[[find_rectangle_at_user_point]] sig>>

val find_line_in_rectangle_at_user_point:
  Figures.point -> Treemap.treemap_rectangle -> drawing -> line option
val find_glyph_in_rectangle_at_user_point:
  Figures.point -> Treemap.treemap_rectangle -> drawing -> glyph option

(* graph code integration *)

val find_def_entity_at_line_opt:
  line -> Treemap.treemap_rectangle -> drawing -> model -> 
  Graph_code.node option
val find_use_entity_at_line_and_glyph_opt:
  line -> glyph -> Treemap.treemap_rectangle -> drawing -> model -> 
  Graph_code.node option

(* macrolevel deps *)
val node_of_rect: 
  Treemap.treemap_rectangle -> model -> Graph_code.node

val deps_readable_files_of_node:
  Graph_code.node -> model -> 
  string (* readable *) deps

val deps_rects_of_rect: 
  Treemap.treemap_rectangle -> drawing -> model ->
  Treemap.treemap_rectangle deps

(* microlevel deps *)
val deps_nodes_of_node_clipped:
  Graph_code.node -> drawing -> model ->
  (Graph_code.node * line * microlevel) deps

(* line highlight *)
val line_and_microlevel_of_node_opt:
  Graph_code.node -> drawing -> model -> 
  (Graph_code.node * line * microlevel) option

val lines_where_used_node:
  Graph_code.node -> line -> microlevel -> line list

@ 

\section{[[Model.ml]]}

<<Model.ml>>=
<<Facebook copyright>>
open Common
open Fpath_.Operators

module F = Figures
module T = Treemap
module E = Entity_code

(*****************************************************************************)
(* The code model *)
(*****************************************************************************)

<<type model>>
and 'a deps = 'a list (* uses *) * 'a list (* users *)

(*****************************************************************************)
(* The drawing model *)
(*****************************************************************************)

type macrolevel = Treemap.treemap_rendering

(* 
 * We use different sources to provide fine-grained semantic visualization:
 * - the source code itself, lexed and parsed in parsing2.ml with language
 *   specific parsers, with the ASTs and tokens stored in a global cache
 * - a language agnostic 'glyph list array' computed from the AST and tokens
 *   by the language specific highlighter
 * - a language agnostic fuzzy defs identification based on the category of 
 *   the glyphs (but containing only "short nodes")
 * - the graph code computed for the whole project, usually not up to
 *   date with the most recent modifications, but containing useful
 *   global information such as the precise set of uses and users of an entity
 * - the light database (but could be replaced by the graph code)
 * 
 * We try to match specific glyphs to the right entity, then use
 * the graph code to find users (and uses) of this entity, and then going
 * from those entities to their corresponding glyph in this file or another
 * file in the whole treemap.
 *)

type microlevel = {
  point_to_line: Figures.point -> line;
  line_to_rectangle: line -> Figures.rectangle;
  layout: layout;
  container: Treemap.treemap_rectangle;
  content: (glyph list) array option;
  (* sorted list of entities by line, defs based on highlighter *)
  defs: (line * short_node) list;
}
 (* 0-indexed line number, which is different from most tools, but
  * programs prefer 0-based index
  *)
  and line = Line of int
 (* Note that I don't use G.node because the string below is not fully
  * qualified so one must use match_short_vs_node when comparing with nodes.
  *)
  and short_node = (string * Entity_code.kind)
  and glyph = {
    str: string;
    categ: Highlight_code.category option;
    font_size: float;
    color: Simple_color.emacs_color;
    (* the lower left position, before calling Cairo.show_text str *)
    mutable pos: Figures.point;
  }
  and layout = {
    lfont_size: float;
    split_nb_columns: float; (* int *)
    width_per_column:float;
    height_per_line: float;
    nblines: float; (* int *)
    nblines_per_column: float; (* int *)
  }



<<type drawing>>

(*****************************************************************************)
(* The world *)
(*****************************************************************************)
type world = {
  mutable dw: drawing;
  dw_stack: drawing Stack_.t;

  (* computed lazily, semantic information about the code *)
  model: model Async.t;

  root_orig: string (* filename *);

  (* to compute a new treemap based on user's action *)
  treemap_func: string (* filename *) list -> Treemap.treemap_rendering;
  (* misc settings, not really used for now *)
  settings: settings;

  mutable current_node: Graph_code.node option;
  mutable current_node_selected: Graph_code.node option;
  mutable current_entity: Database_code.entity option;
}
   and settings = {
     mutable draw_summary: bool;
     mutable draw_searched_rectangles: bool;
   }

(*****************************************************************************)
(* Builders *)
(*****************************************************************************)

<<[[new_pixmap]]()>>

<<[[init_drawing]]()>>

(*****************************************************************************)
(* The drawing context *)
(*****************************************************************************)

<<type context>>

let context_of_drawing dw model = { 
  nb_rects_on_screen = dw.nb_rects;
  model2 = model;
  grep_query = dw.current_grep_query;
  layers_microlevel = dw.layers.Layer_code.micro_index;
}

(*****************************************************************************)
(* Point -> (rectangle, line, glyph, entity) *)
(*****************************************************************************)

<<[[find_rectangle_at_user_point]]()>>


let find_line_in_rectangle_at_user_point user r dw =
  try 
    let microlevel = Hashtbl.find dw.microlevel r in
    let line = microlevel.point_to_line user in
    Some line
  with Not_found -> None

let find_glyph_in_rectangle_at_user_point user r dw =
  let* line = find_line_in_rectangle_at_user_point user r dw in
    let microlevel = Hashtbl.find dw.microlevel r in
    let* glyphs = microlevel.content in
      let (Line line) = line in
      if line >= Array.length glyphs
      then None
      else
        let glyphs = glyphs.(line) in
        (* find the best one *)
        glyphs |> List.rev |> List.find_opt (fun glyph ->
          let pos = glyph.pos in
          user.Figures.x >= pos.Figures.x
        )
    
  

(*****************************************************************************)
(* Graph code integration *)
(*****************************************************************************)

let match_short_vs_node (str, short_kind) node =
  Graph_code.shortname_of_node node = str &&
  Database_code.matching_def_short_kind_kind short_kind (snd node)

(* when in a file we have both the prototype (forward decl) and
 * the def, we prefer the def.
 *)
let rank_entity_kind = function
  | E.Function | E.Global -> 3
  | E.Prototype | E.GlobalExtern -> 1
  | _ -> 2

(* We used to just look in hentities_of_file for the line mentioned
 * in the graph_code database, but the file may have changed so better
 * instead to rely on microlevel.defs.
 *)
let find_def_entity_at_line_opt line tr dw model =
  let file = tr.T.tr_label in
  let readable = (Filename_.readable ~root:(model.root) (file)) in
  try 
    let nodes = Hashtbl.find model.hentities_of_file readable in
    let microlevel = Hashtbl.find dw.microlevel tr in
    let short_node = List.assoc line microlevel.defs in
    (* try to match the possible shortname str with a fully qualified node 
    *)
    nodes |> List_.filter_map (fun node ->
      if match_short_vs_node short_node node
      then Some node
      else None
    ) |> List.map (fun (s, kind) -> ((s, kind), rank_entity_kind kind))
      |> Assoc.sort_by_val_highfirst
      |> List.hd |> fst |> (fun x -> Some x)
  with Not_found | Failure _ (* "hd"*) -> None

let find_use_entity_at_line_and_glyph_opt line glyph tr dw model =
  let* g = model.g in
    (* find enclosing def line *)
    let microlevel = Hashtbl.find dw.microlevel tr in
    (* try because maybe have no enclosing defs *)
    try 
      let (line_def, _shortnode) = 
        microlevel.defs |> List.rev |> List.find (fun (line2, _shortnode) ->
          line >= line2
        )
      in
      let* node = find_def_entity_at_line_opt line_def tr dw model in
        let uses = Graph_code.succ node Graph_code.Use g in
        uses |> List.find_opt (fun node ->
          let s = Graph_code.shortname_of_node node in
          let categ =  glyph.categ ||| Highlight_code.Normal in
          glyph.str = s &&
          Database_code.matching_use_categ_kind categ (snd node)
        )
    with Not_found -> None


let node_of_rect tr model =
  let file = tr.Treemap.tr_label in
  let readable = (Filename_.readable ~root:(model.root) (file)) in
  let kind = if tr.Treemap.tr_is_node then E.Dir else E.File in
  readable, kind


let deps_readable_files_of_node node model =
  match node, model.g with
  | (_, (E.Dir | E.File)), _ -> 
      (* opti: can't use g for that *)
      (try Hashtbl.find model.hfile_deps_of_node node with Not_found -> [], [])
  | _, None -> [], []
  | _, Some g ->
      let succ = Graph_code.succ node Graph_code.Use g in
      let pred = Graph_code.pred node Graph_code.Use g in
      succ |> List_.filter_map (fun n ->
        try Some !!(Graph_code.file_of_node n g) with Not_found -> None
      ),
      pred |> List_.filter_map (fun n ->
        try Some !!(Graph_code.file_of_node n g) with Not_found -> None
      )

let deps_rects_of_rect tr dw model =
  let node = node_of_rect tr model in
  let uses, users = deps_readable_files_of_node node model in
  uses |> List_.filter_map (fun file -> 
    Common2_.optionise (fun () -> Hashtbl.find dw.readable_file_to_rect file)
  ),
  users |> List_.filter_map (fun file ->
    Common2_.optionise (fun () ->Hashtbl.find dw.readable_file_to_rect file)
  )

let line_and_microlevel_of_node_opt n dw model =
  let* g = model.g in
    try 
      let file = !!(Graph_code.file_of_node n g) in
      (* rectangles not on the screen will be automatically "clipped"
       * as this may raise Not_found 
       *)
      let rect = Hashtbl.find dw.readable_file_to_rect file in
      let microlevel = Hashtbl.find dw.microlevel rect in
      let line = microlevel.defs |> List.find (fun (_line, snode) ->
        match_short_vs_node snode n
      ) |> fst in
      Some (n, line, microlevel)
    with Not_found -> None
  

let uses_or_users_of_node node dw fsucc model =
  match model.g with
  | None -> []
  | Some g ->
    let succ = fsucc node Graph_code.Use g in
    succ |> List_.filter_map (fun n -> 
      line_and_microlevel_of_node_opt n dw model
    )

let deps_nodes_of_node_clipped node dw model =
  uses_or_users_of_node node dw Graph_code.succ model,
  uses_or_users_of_node node dw Graph_code.pred model


let lines_where_used_node node startl microlevel =
  let s = Graph_code.shortname_of_node node in
  let s =
    (* ugly: see Graph_code_clang.new_str_if_defs() where we rename dupes *)
    match s with
    | _ when (s =~ "\\(.*\\)__[0-9]+$") -> Common.matched1 s
    | _ when (s =~ "^\\$\\(.*\\)") -> Common.matched1 s
    | _ -> s
  in
  
  let (Line startl) = startl in
  match microlevel.content with
  | None -> []
  | Some glypys ->
    let res = ref [] in
    (* todo: should be from startl to endl (the start of the next entity) *)
    for line = startl to Array.length glypys - 1 do
      let xs = glypys.(line) in
      if xs |> List.exists (fun glyph ->
        let categ =  glyph.categ ||| Highlight_code.Normal in
        glyph.str = s &&
        Database_code.matching_use_categ_kind categ (snd node)
      )
      then Stack_.push (Line line) res
    done;
    !res

@ 

\section{[[View.mli]]}


<<View.mli>>=
<<[[mk_gui]] sig>>
@ 


\section{[[View.ml]]}

<<View.ml>>=
<<Facebook copyright>>
open Common2_
open Common
module Log = Log_viewer.Log
module G = Gui
module K = GdkKeysyms
module T = Treemap
module CairoH = Cairo_helpers
open Model (* for the fields *)
module Flag = Flag_visual
module Db = Database_code

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Globals *)
(*****************************************************************************)

<<view globals>>

(*****************************************************************************)
(* Final view rendering *)
(*****************************************************************************)

(* ---------------------------------------------------------------------- *)
(* The main-map *)
(* ---------------------------------------------------------------------- *)

<<[[assemble_layers]]>>

<<expose>>

<<configure>>

(* ---------------------------------------------------------------------- *)
(* The legend *)
(* ---------------------------------------------------------------------- *)
<<[[expose_legend]]>>

(*****************************************************************************)
(* The main UI *)
(*****************************************************************************)

<<[[mk_gui]]()>>

@ 


\section{[[Controller.mli]]}

<<Controller.mli>>=

val _refresh_da: (unit -> unit) ref
val _refresh_legend: (unit -> unit) ref

val _go_back: (Model.world -> unit) ref
val _go_dirs_or_file: 
  (?current_grep_query: (string, Model.line) Hashtbl.t option ->
    Model.world -> string (* filename *) list -> unit
  ) ref

val _statusbar_addtext: (string -> unit) ref
val _set_title: (string -> unit) ref

val current_rects_to_draw:
  (Treemap.treemap_rectangle list) ref
val current_r:
  Treemap.treemap_rectangle option ref
val hook_finish_paint: (unit -> unit) ref

val paint_content_maybe_refresher:
  GMain.Idle.id option ref
val current_motion_refresher:
  GMain.Idle.id option ref
val current_tooltip_refresher:
  GMain.Timeout.id option ref

val title_of_path: string -> string

@ 

\section{[[Controller.ml]]}

<<Controller.ml>>=
<<Facebook copyright>>

(* refresh drawing area *)
let _refresh_da = ref (fun () ->
  failwith "_refresh_da not defined"
)
let _refresh_legend = ref (fun () ->
  failwith "_refresh_legend not defined"
)

let current_rects_to_draw = ref []
let hook_finish_paint = ref (fun () ->
  ()
)

let current_r = ref None

let paint_content_maybe_refresher = ref None
let current_motion_refresher = ref None
let current_tooltip_refresher = ref None

let _go_back = ref (fun _w ->
  failwith "_go_back not defined"
)

let _go_dirs_or_file = ref 
 (fun ?(current_grep_query=None)  _dw_ref _paths ->
   ignore current_grep_query;
  failwith "_go_dirs_or_file not defined"
)

let _statusbar_addtext = ref (fun _s ->
  failwith "_statusbar_addtext not defined"
)
let _set_title = ref (fun _s ->
  failwith "_set_title not defined"
)

let title_of_path s = "CodeMap: " ^ s

@ 

\section{[[help.mli]]}

<<help.mli>>=
val interface_doc: string

@ 

\section{[[help.ml]]}

<<help.ml>>=
<<[[interface_doc]]>>
@ 


\section{[[draw_macrolevel.mli]]}

<<draw_macrolevel.mli>>=

<<[[draw_treemap_rectangle]] sig>>

val draw_trect_using_layers:
  cr:Cairo.context ->
  Layer_code.layers_with_index ->
  Treemap.treemap_rectangle -> 
  unit

@ 

\section{[[draw_macrolevel.ml]]}

<<draw_macrolevel.ml>>=
<<Facebook copyright>>
open Common2_.ArithFloatInfix

open Figures (* for the fields *)
module T = Treemap
module Color = Simple_color

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Drawing a treemap rectangle *)
(*****************************************************************************)

<<[[draw_treemap_rectangle]]()>>


(*****************************************************************************)
(* Layers macrolevel *)
(*****************************************************************************)

(* How should we draw layer information at the macro level ?
 *   
 *  - fill the rectangle with the color of one layer ? 
 *  - separate equally among layers ? 
 *  - draw on top of the existing archi color ?
 *  - draw circles instead of rectangle so have quantitative information too 
 *    (like I was doing when display git related commit information).
 * 
 * It is maybe good to not draw on top of the existing archi_code color. 
 * Too many colors kill colors. Also we can not convey quantitative 
 * information by coloring with full rectangles (instead of the random
 * circles trick) but for some layers like security it is probably better.
 * Don't care so much about how many bad calls; care really about
 * number of files with bad calls in them.
 * 
 * So for now we just fill rectangles with colors from the layer and
 * when a file matches multiple layers we split the rectangle in equal
 * parts.
 *)

let draw_trect_using_layers ~cr layers_with_index rect =
  (* don't use archi_code color. Just black and white *)
  let is_file = not rect.T.tr_is_node in
  let color = if is_file then "white" else "black" in
  draw_treemap_rectangle ~cr ~color:(Some color) rect;

  if is_file then begin
    let file = rect.T.tr_label in
    
    let color_info = 
      try Hashtbl.find layers_with_index.Layer_code.macro_index file
      with Not_found -> []
    in
    (* What to draw? TODO a splitted rectangle? *)
    let sorted = Common2_.sort_by_key_highfirst color_info in
    (match sorted with
    | [] -> ()
    | (_float, color)::_rest ->
      draw_treemap_rectangle ~cr ~color:(Some color) rect;
    );
  end

<<[[draw_summary_content]]>>
@ 

\section{[[draw_microlevel.mli]]}

<<draw_microlevel.mli>>=

<<[[draw_treemap_rectangle_content_maybe]] sig>>

<<[[text_with_user_pos]] sig>>

val draw_magnify_line:
  ?honor_color:bool ->
  Cairo.context -> Model.line -> Model.microlevel -> unit
@ 

\section{[[draw_microlevel.ml]]}

<<draw_microlevel.ml>>=
<<Facebook copyright>>
open Common
open Either
open Common2_.ArithFloatInfix

open Figures (* for the fields *)
open Model (* for the fields *)
module F = Figures
module M = Model
module T = Treemap
module Color = Simple_color
module CairoH = Cairo_helpers
module Flag = Flag_visual
module FT = Ftype

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

(* There are many different coordinates relevant to the lines of a file:
 *  - line number in the file
 *  - column and line in column for the file when rendered in multiple columns
 *  - x,y position relative to the current treemap rectangle
 *  - x,y position on the screen in normalized coordinates
 *  - x,y position on the screen in pixels
 * We have many functions below to go from one to the other.
 * 
 * note: some types below could be 'int' but it's more convenient to have
 * everything as a float because arithmetic with OCaml sucks when have
 * multiple numeric types.
 * 
 * Below line numbers starts at 0, not at 1 as in emacs.
 *)

type _line = Model.line

type line_in_column = {
  column: float; (* int *)
  line_in_column: float; (* int *)
}

type _pos = float (* x *) * float (* y *)

type _point = Figures.point

<<type [[draw_content_layout]]>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

let is_big_file_with_few_lines ~nblines file = 
  nblines < 20. && Common2_.filesize_eff file > 4000

(* coupling: with parsing2.ml, todo move in parsing2.ml? *)
let use_fancy_highlighting file =
  match FT.of_file (Fpath.v file) with
  (* not yet *)
  | FT.PL (FT.IDL FT.Protobuf) -> false

  (* the one handled by parsing2.ml *)
  | ( FT.PL (FT.OCaml _)
    | FT.Text ("nw" | "tex"  | "texi" | "web" | "org")
    | FT.PL (FT.Web (FT.Php _ | FT.Js | FT.TypeScript | FT.Html))
    | FT.PL (FT.IDL _)
    (* TODO: FT.Makefile, but not tree-sitter-make yet
     * TODO: Yaml, but bad tokens still in Parse_languages.ml
     *)
    | FT.Config (FT.Dockerfile | FT.Jsonnet | FT.Sexp)
    | FT.PL (FT.Cplusplus _ | FT.C _ | FT.ObjectiveC _)
    | FT.PL (FT.Scala)
    | FT.PL (FT.Lisp _)
    | FT.PL (FT.Haskell _)
    | FT.PL (FT.Python)
    | FT.PL (FT.Csharp)
    | FT.PL (FT.Java)
    (*    | FT.PL (FT.Prolog _) *)
    | FT.PL (FT.Erlang)
    | FT.PL (FT.Rust)
    | FT.PL (FT.Skip)
    | FT.PL (FT.Go)
    | FT.PL (FT.Ruby)
    | FT.PL (FT.Script _)
    ) -> true
  | (FT.Text "txt") when Filename.basename file = "info.txt" -> true
  | _ -> false

(*****************************************************************************)
(* Coordinate conversion *)
(*****************************************************************************)

let line_in_column_to_bottom_pos lc r layout =
  let x = r.p.x + (lc.column * layout.width_per_column) in
  (* to draw text in cairo we need to be one line below, hence the +1
   * as y goes down but the text is drawn above
   *)
  let y = r.p.y + ((lc.line_in_column + 1.) * layout.height_per_line) in
  x, y

let line_to_line_in_column line layout =
  let (Line line) = line in
  let line = float_of_int line in
  let column = floor (line / layout.nblines_per_column) in
  let line_in_column = 
    line - (column * layout.nblines_per_column) in
  { column; line_in_column }

let line_to_rectangle line r layout =
  let lc = line_to_line_in_column line layout in
  (* this is the bottom pos, so we need to substract height_per_line
   * if we want to draw above the bottom pos
   *)
  let x, y = line_in_column_to_bottom_pos lc r layout in
  { p = { x; 
          y = y - layout.height_per_line };
    q = { x = x + layout.width_per_column; 
          y = y + 0.2 * layout.height_per_line };
  }

let point_to_line pt r layout =
  let x = pt.Figures.x - r.p.x in
  let y = pt.Figures.y - r.p.y in
  let line_in_column = floor (y / layout.height_per_line) in
  let column = floor (x / layout.width_per_column) in
  Line ((column * layout.nblines_per_column + line_in_column) |> int_of_float)

(*****************************************************************************)
(* Content properties *)
(*****************************************************************************)

(* Anamorphic entities *)
<<[[final_font_size_of_categ]]>>

let color_of_categ categ =
  let attrs =
    match categ with
    | None ->       Highlight_code.info_of_category Highlight_code.Normal
    | Some categ -> Highlight_code.info_of_category categ
  in
  attrs |> List_.find_some (fun attr ->
    match attr with
    | `FOREGROUND s 
    | `BACKGROUND s (* todo: should really draw the background of the text *)
      -> 
        Some (s)
    | _ -> None
  )

let glyphs_of_file ~font_size ~font_size_real model_async file 
  : (glyph list) array option =

  (* real position is set later in draw_content *)
  let pos = { Figures.x = 0.; y = 0. } in

  match FT.of_file (Fpath.v file) with
  | _ when use_fancy_highlighting file ->
     Logs.debug (fun m -> m "fancy highlighting for %s" file);

    let entities = 
      match Async.async_get_opt model_async with
      | Some model -> model.hentities 
      | None -> Hashtbl.create 0
    in

    (* if you have some cache in tokens_with_categ_of_file, then it
     * must be invalidated when a file has changed on the disk, otherwise
     * we can get some Array out of bound exceptions as the number of lines
     * returned by nblines_eff may be different
     *)
    let nblines = Common2.nblines_eff file in
    let arr = Array.make nblines [] in
    let tokens_with_categ = Parsing.tokens_with_categ_of_file file entities in

    let line = ref 0 in
    let acc = ref [] in
    (try
     tokens_with_categ |> List.iter (fun (s, categ, _filepos) ->
      let final_font_size = 
        final_font_size_of_categ ~font_size ~font_size_real categ in
      let color = 
        color_of_categ categ in

      let xs = Common2_.lines_with_nl_either s in
      xs |> List.iter (function
      | Left str ->
          Stack_.push { M. str; font_size=final_font_size; color; categ;pos } 
            acc;
      | Right () ->
          arr.(!line) <- List.rev !acc;
          acc := [];
          incr line;
      )
    );
    if !acc <> []
    then arr.(!line) <- List.rev !acc;
    Some arr
   with Invalid_argument("index out of bounds") ->
      failwith (spf "try on %s, nblines = %d, line = %d" file nblines !line)
    )

  | FT.PL _ | FT.Text _ | FT.Config _ ->
     Logs.debug (fun m -> m "black highlighting for %s" file);
      UFile.Legacy.cat file
      |> List.map (fun str -> 
        [{ M.str; font_size; color = "black"; categ=None; pos }])
      |> Array.of_list
      |> (fun x -> Some x)

  | _ ->
     Logs.debug (fun m -> m "no highlighting for %s" file);
     None

let defs_of_glyphs glyphs =
  let res = ref [] in
  glyphs |> Array.iteri (fun line_0_indexed glyphs ->
    glyphs |> List.iter (fun glyph ->
      glyph.categ |> Option.iter (fun categ ->
        Database_code.entity_kind_of_highlight_category_def categ 
        |> Option.iter (fun kind ->
              Stack_.push (Line line_0_indexed, (glyph.str, kind)) res
        ))));
  List.rev !res

(*****************************************************************************)
(* Columns *)
(*****************************************************************************)

<<[[font_size_when_have_x_columns]]>>
   
<<[[optimal_nb_columns]]>>

<<[[draw_column_bars]]>>


(*****************************************************************************)
(* File Content *)
(*****************************************************************************)

<<[[draw_content]]>>


<<[[draw_treemap_rectangle_content_maybe]]>>

(*****************************************************************************)
(* Magnifyer Content *)
(*****************************************************************************)

(* alt: digital zoom? good enough? need rendering at better resolution? *)
let draw_magnify_line ?(honor_color=true) cr line microlevel =
  match microlevel.content with
  | None -> ()
  | Some glyphs ->
    let r = microlevel.container.T.tr_rect in
    let layout = microlevel.layout in

    let lc = line_to_line_in_column line layout in
    let x, y = line_in_column_to_bottom_pos lc r layout in
    Cairo.move_to cr x y;
    
    let (Line iline) = line in
    (* because of the way we layout code in multiple columns with different
     * fonts, we may not use the whole rectangle to draw the content of
     * a file and so the cursor could be far below the last line of
     * the file
     *)
    if iline < Array.length glyphs then begin
     glyphs.(iline) 
     |> (fun xs ->
      match xs with
      | [] -> []
      | x::xs ->
        if x.M.str =~ "[ \t]+" then xs
        else x::xs
    )
    |> List.iter (fun glyph ->
      (* let font_size = glyph.M.font_size * 3. in *)
      let font_size_real = 15. in
      let font_size = CairoH.device_to_user_size cr font_size_real in
      Cairo.set_font_size cr font_size;
      let color = 
        if honor_color 
        then glyph.color
        else "wheat"
      in
      let (r,g,b) = Color.rgbf_of_string color in
      let alpha = 1. in
      Cairo.set_source_rgba cr r g b alpha;
      CairoH.show_text cr glyph.M.str;
    )
    end
@ 

\section{[[draw_labels.mli]]}

<<draw_labels.mli>>=

<<[[draw_treemap_rectangle_label_maybe]] sig>>

@ 

\section{[[draw_label.ml]]}

<<draw_labels.ml>>=
<<Facebook copyright>>
open Common2_.ArithFloatInfix

open Figures (* for the fields *)

module Flag = Flag_visual

module T = Treemap
module F = Figures
module Color = Simple_color

module CairoH = Cairo_helpers

(*****************************************************************************)
(* Label *)
(*****************************************************************************)

<<[[draw_treemap_rectangle_label_maybe]]>>

@ 

\section{[[draw_legend.mli]]}

<<draw_legend.mli>>=
val draw_legend: cr:Cairo.context -> unit

val draw_legend_layer: cr:Cairo.context -> Layer_code.layers_with_index -> unit

@

\section{[[draw_legend.ml]]}

<<draw_legend.ml>>=
<<Facebook copyright>>
open Common2_.ArithFloatInfix

module CairoH = Cairo_helpers
module L = Layer_code

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

let draw_legend_of_color_string_pairs ~cr xs = 

  Cairo.select_font_face cr "serif" ~weight:Cairo.Normal;
  let size = 25.  in

  Cairo.set_font_size cr (size * 0.6);
  Cairo.set_source_rgba cr 0. 0. 0.    1.0;
  
  xs |> List_.index_list_1 |> List.iter (fun ((color,s), i) ->
    let x = 10. in
    let y = float_of_int i * size in

    let w = size in
    let h = size in

    CairoH.fill_rectangle ~cr ~color ~x ~y ~w ~h ();
    Cairo.set_source_rgba cr 0. 0. 0.    1.0;
    Cairo.move_to cr (x + size * 2.) (y + size * 0.8);
    Cairo.show_text cr s;
  )
  
(*****************************************************************************)
(* Drawing *)
(*****************************************************************************)

<<[[paint_legend]]>>

let draw_legend_layer ~cr layers_idx = 
  let pairs = 
    layers_idx.L.layers |> List_.filter_map (fun (layer, is_active) ->
      if is_active
      then Some layer.L.kinds
      else None
    ) |> List.flatten |> List.map (fun (a, b) -> (b, a))
  in
  draw_legend_of_color_string_pairs ~cr pairs

@


\section{[[view_mainmap.mli]]}

<<view_mainmap.mli>>=

val paint: Model.drawing -> Model.model Async.t -> unit

val zoom_pan_scale_map: Cairo.context -> Model.drawing -> unit

val device_to_user_area: Model.drawing -> Figures.rectangle

val with_map: Model.drawing -> (Cairo.context -> 'a) -> 'a

val button_action:
   Model.world -> GdkEvent.Button.t -> bool

@ 

\section{[[view_mainmap.ml]]}

<<view_mainmap.ml>>=
<<Facebook copyright>>
open Common
open Fpath_.Operators
(* floats are the norm in graphics *)
open Common2_.ArithFloatInfix
open Model
module CairoH = Cairo_helpers
module F = Figures
module T = Treemap
module Flag = Flag_visual
module M = Model
module Ctl = Controller

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* 
 * This module calls Draw_macrolevel and Draw_microlevel and assembles
 * the final "painting" of the code "main map". It is called mainly by
 * View2.configure and Ui_navigation.go_dirs_and_file.
 * 
 * Painting is not the last element in the "main map" rendering pipeline.
 * There is also View_overlay which is called mainly when the user
 * moves the mouse which triggers the View_overlay.motion_refresher
 * callback which just add overlays on top of the already drawn (and
 * computationaly expensive) painting done here. 
 *)

(*****************************************************************************)
(* Scaling *)
(*****************************************************************************)

<<[[zoom_pan_scale_map]]>>

<<[[with_map]]>>

<<[[device_to_user_area]]>>

(*****************************************************************************)
(* Painting *)
(*****************************************************************************)

<<paint>>

(*****************************************************************************)
(* Events *)
(*****************************************************************************)

<<[[key_pressed]]>>
<<[[find_filepos_in_rectangle_at_user_point]]>>
   
<<[[button_action]]>>

@ 

\section{[[view_minimap.mli]]}

<<view_minimap.mli>>=
@ 

\section{[[view_minimap.ml]]}

<<view_minimap.ml>>=
<<Facebook copyright>>

(*****************************************************************************)
(* Scaling *)
(*****************************************************************************)

<<[[scale_minimap]]>>

<<[[with_minimap]]>>

(*****************************************************************************)
(* Painting *)
(*****************************************************************************)

<<[[paint_minimap]]>>

(* ---------------------------------------------------------------------- *)
(* The mini-map *)
(* ---------------------------------------------------------------------- *)

<<[[expose_minimap]]>>

<<[[configure_minimap]]>>

(* ---------------------------------------------------------------------- *)
(* The mini-map *)
(* ---------------------------------------------------------------------- *)

<<[[motion_notify_minimap]]>>

<<[[button_action_minimap]]>>

@ 


\section{[[view_overlays.mli]]}

<<view_overlays.mli>>=

val draw_searched_rectangles:
  dw:Model.drawing -> unit

val motion_notify:
  Model.world -> GdkEvent.Motion.t -> bool

val paint_initial:
  Model.drawing -> unit
val hook_finish_paint:
  Model.world -> unit

@ 


\section{[[view_overlays.ml]]}

<<view_overlays.ml>>=
<<Facebook copyright>>
open Common
(* floats are the norm in graphics *)
open Common2_.ArithFloatInfix
open Model
module T = Treemap
module CairoH = Cairo_helpers
module M = Model

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* 
 * This module mainly modifies the dw.overlay cairo surface. It also
 * triggers the refresh_da which triggers itself the expose event
 * which triggers the View2.assemble_layers composition of dw.pm with
 * dw.overlay.
 *)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

let readable_txt_for_label txt current_root =
  let readable_txt = 
    if current_root = txt (* when we are fully zoomed on one file *)
    then "root"
    else (Filename_.readable ~root:(current_root) (txt))
  in
  if String.length readable_txt > 25
  then 
    let dirs = Filename.dirname readable_txt |> String_.split ~sep:"/" in
    let file = Filename.basename readable_txt in
    spf "%s/.../%s" (List.hd dirs) file
  else readable_txt

let with_overlay dw f =
  let cr_overlay = Cairo.create dw.overlay in
  View_mainmap.zoom_pan_scale_map cr_overlay dw;
  f cr_overlay

(*****************************************************************************)
(* The overlays *)
(*****************************************************************************)

(* ---------------------------------------------------------------------- *)
(* The current filename *)
(* ---------------------------------------------------------------------- *)
<<[[draw_label_overlay]]>>

(* ---------------------------------------------------------------------- *)
(* The current rectangles *)
(* ---------------------------------------------------------------------- *)

<<[[draw_rectangle_overlay]]>>

(* ---------------------------------------------------------------------- *)
(* Uses and users macrolevel *)
(* ---------------------------------------------------------------------- *)
let draw_deps_files tr dw model =
 with_overlay dw (fun cr_overlay ->
   let uses_rect, users_rect = M.deps_rects_of_rect tr dw model in
   (* todo: glowing layer *)
   uses_rect |> List.iter (fun r ->
     CairoH.draw_rectangle_figure ~cr:cr_overlay ~color:"green" r.T.tr_rect;
   );
   users_rect |> List.iter (fun r ->
     CairoH.draw_rectangle_figure ~cr:cr_overlay ~color:"red" r.T.tr_rect;
   )
 )

(* ---------------------------------------------------------------------- *)
(* Uses and users microlevel *)
(* ---------------------------------------------------------------------- *)
(* todo: better fisheye, with good background color *)
let draw_magnify_line_overlay_maybe ?honor_color dw line microlevel =
  with_overlay dw (fun cr_overlay ->
    let font_size = microlevel.layout.lfont_size in
    let font_size_real = CairoH.user_to_device_font_size cr_overlay font_size in

    (* todo: put in style *)
    if font_size_real < 5.
    then Draw_microlevel.draw_magnify_line 
          ?honor_color cr_overlay line microlevel
  )

let draw_deps_entities n dw model =
 with_overlay dw (fun cr_overlay ->

   line_and_microlevel_of_node_opt n dw model 
   |> Option.iter (fun (_n2, line, microlevel) ->
     let rectangle = microlevel.line_to_rectangle line in
     CairoH.draw_rectangle_figure ~cr:cr_overlay ~color:"white" rectangle
   );

   let uses, users = M.deps_nodes_of_node_clipped n dw model in
   uses |> List.iter (fun (_n2, line, microlevel) ->
     let rectangle = microlevel.line_to_rectangle line in
     CairoH.draw_rectangle_figure ~cr:cr_overlay ~color:"green" rectangle;
   );
   users |> List.iter (fun (_n2, line, microlevel) ->
     let rectangle = microlevel.line_to_rectangle line in
     CairoH.draw_rectangle_figure ~cr:cr_overlay ~color:"red" rectangle;
     
     let lines_used = M.lines_where_used_node n line microlevel in
     lines_used |> List.iter (fun line ->
       let rectangle = microlevel.line_to_rectangle line in
       CairoH.draw_rectangle_figure ~cr:cr_overlay ~color:"purple" rectangle;

       draw_magnify_line_overlay_maybe ~honor_color:false dw line microlevel;
     );
   );
 )

(* ---------------------------------------------------------------------- *)
(* Tooltip/hovercard current entity *)
(* ---------------------------------------------------------------------- *)
(* assumes cr_overlay has not been zoom_pan_scale *)
let draw_tooltip ~cr_overlay ~x ~y n g =

  let pred = Graph_code.pred n Graph_code.Use g in
  let succ = Graph_code.succ n Graph_code.Use g in
  let files = 
    pred 
    |> List_.filter_map (fun n ->
        Common2_.optionise (fun () -> (Graph_code.file_of_node n g)))
    |> List_.sort |> Common2.uniq
  in
  let str = spf "
 Entity: %s
 #Users: %d (%d different files)
 #Uses: %d
" (Graph_code.string_of_node n) 
    (List.length pred) (List.length files)
    (List.length succ)
  in
  let xs = Common2_.lines str in

  (* copy paste of draw_label_overlay *)
  Cairo.select_font_face cr_overlay "serif" ~weight:Cairo.Normal;
  Cairo.set_font_size cr_overlay Style.font_size_filename_cursor;

  let template = "peh" in
  let max_length = 
    xs |> List.map (String.length) |> Common2.maximum |> float_of_int in

  let extent = CairoH.text_extents cr_overlay template in
  let tw = extent.Cairo.width * ((max_length / 3.) |> ceil) in
  let th = extent.Cairo.height * 1.2 in

  let nblines = List.length xs |> float_of_int in
  let refx = x - tw / 2. in
  let refy = y - (th * nblines) in

  CairoH.fill_rectangle ~cr:cr_overlay 
    ~x:(refx + extent.Cairo.x_bearing) ~y:(refy + extent.Cairo.y_bearing)
    ~w:tw ~h:(th * nblines)
    ~color:"black"
    ~alpha:0.5
    ();

  Cairo.set_source_rgba cr_overlay 1. 1. 1.    1.0;
  xs |> List_.index_list_0 |> List.iter (fun (txt, line) ->
    let line = float_of_int line in
    Cairo.move_to cr_overlay refx (refy + line * th);
    CairoH.show_text cr_overlay txt;
  );
  ()

(* ---------------------------------------------------------------------- *)
(* The selected rectangles *)
(* ---------------------------------------------------------------------- *)

<<[[draw_searched_rectangles]]>>

<<[[zoomed_surface_of_rectangle]]>>

(*****************************************************************************)
(* Assembling overlays *)
(*****************************************************************************)

let paint_initial dw =
  let cr_overlay = Cairo.create dw.overlay in
  CairoH.clear cr_overlay
  (* can't do draw_deps_entities w.current_node here because
   * of lazy_paint(), the file content will not be ready yet
   *)

(* a bit ugly, but have to because of lazy_paint optimization *)
let hook_finish_paint w =
  (* pr2 "Hook_finish_paint"; *)
  let dw = w.dw in
  w.current_node |> Option.iter (fun n -> 
    Async.async_get_opt w.model |> Option.iter (fun model ->
      draw_deps_entities n dw model
    ));
  w.current_node_selected |> Option.iter (fun n -> 
    Async.async_get_opt w.model |> Option.iter (fun model ->
      draw_deps_entities n dw model
    ))

<<[[motion_refresher]]>>

<<idle>>

@ 

\section{[[ui_search.mli]]}

<<ui_search.mli>>=

val dialog_search_def: 
  Model.model Async.t -> string option

val run_grep_query:
  root:string -> string -> (string * Model.line) list

val run_tbgs_query:
  root:string -> string -> (string * Model.line) list

@ 


\section{[[ui_search.ml]]}

<<ui_search.ml>>=
<<Facebook copyright>>
open Common

module G = Gui
module M = Model

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*
 * todo:
 *  - integrate lfs at some point!
 *  - integrate pof at some point!
 *)


(* ---------------------------------------------------------------------- *)
(* Search *)
(* ---------------------------------------------------------------------- *)

<<[[dialog_search_def]]>>

<<[[run_grep_query]]>>

<<[[run_tbgs_query]]>>

@ 

\section{[[ui_navigation.mli]]}

<<ui_navigation.mli>>=

val go_back: 
  Model.world -> unit

val go_dirs_or_file:
  ?current_grep_query:(string (* filename *), Model.line) Hashtbl.t option ->
  Model.world -> string (* filename *) list -> unit

@ 

\section{[[ui_navigation.ml]]}

<<ui_navigation.ml>>=
<<Facebook copyright>>
open Common
open Model

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Navigation *)
(*****************************************************************************)

<<[[go_back]]>>

<<[[go_dirs_or_file]]>>

@ 




\section{[[Parsing.mli]]}

\section{[[Parsing.ml]]}

\section{[[Completion.mli]]}

<<Completion.mli>>=
<<signature [[my_entry_completion_eff]]>>

<<signature [[build_completion_defs_index]]>>
@

\section{[[Completion.ml]]}

\section{[[Style.mli]]}

\section{[[Style.ml]]}

<<Style.ml>>=
<<Facebook copyright>>
open Common

module E = Entity_code
module HC = Highlight_code

(*****************************************************************************)
(* Visual style *)
(*****************************************************************************)
(* see also model2.settings *)

<<[[zoom_factor_incruste_mode]]>>

<<[[threshold_draw_dark_background_font_size_real]]>>

let font_size_filename_cursor = 30.

(* see also Cairo_helpers.prepare_string which may double the spaces *)
let font_text = 
  match 0 with
  | 0 -> "serif"

  | 1 -> "helvetica"
  | 2 -> "courier"
  | 3 -> "arial"
  | 4 -> "consolas"
  | 5 -> "dejavu"
  | 6 -> "terminal"
  | _ -> raise Impossible

<<[[size_font_multiplier_of_categ]]()>>

<<[[windows_params]]()>>

@ 

\section{[[editor_connection.mli]]}


\section{[[editor_connection.ml]]}

<<editor_connection.ml>>=
<<Facebook copyright>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Emacs *)
(*****************************************************************************)

<<emacs configuration>>

(*****************************************************************************)
(* Vi *)
(*****************************************************************************)

(*****************************************************************************)
(* Wrappers *)
(*****************************************************************************)

<<[[open_file_in_current_editor]]()>>
@ 

\section{[[async.mli]]}

<<async.mli>>=

<<type async>>
<<async functions sig>>

@ 

\section{[[async.ml]]}

<<async.ml>>=
<<Facebook copyright>>

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Type *)
(*****************************************************************************)

<<type async>>

(*****************************************************************************)
(* Functions *)
(*****************************************************************************)

<<async functions>>

@ 

\section{[[cairo_helpers.mli]]}


<<cairo_helpers.mli>>=

<<cairo helpers functions sig>>
@ 

\section{[[cairo_helpers.ml]]}

<<cairo_helpers.ml>>=
<<Facebook copyright>>
(* floats are the norm in graphics *)
open Common2_.ArithFloatInfix

open Figures
module F = Figures
module Color = Simple_color

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* See http://archimedes.forge.ocamlcore.org/cairo/ for a tutorial on 
 * Cairo in OCaml.
 *)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

(*****************************************************************************)
(* Text related *)
(*****************************************************************************)

(* May have to move this in commons/ at some point *)

let _re_space = Str.regexp "^[ ]+$"
let _re_tab = Str.regexp "^[\t]+$"

<<cairo helpers functions>>

@ 

\chapter{Changelog}
\label{sec:changelog}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%src: wc.nw in noweb source
Here is a list of the identifiers used, and where they appear.
Underlined entries indicate the place of definition.
This index is generated automatically.

%\twocolumn does not work
\nowebindex

%\chapter{References} 
\addcontentsline{toc}{section}{References}


\bibliography{latex/Principia}
\bibliographystyle{alpha}

%\begin{thebibliography}{99}
%
%\bibitem[1]{wp-literate-programming} Donald Knuth,,
%{\em Literate Programming}, 
%\url{http://en.wikipedia.org/wiki/Literate\_Program}
%
%\bibitem[2]{noweb} Norman Ramsey,
%{\em Noweb}, 
%\url{http://www.cs.tufts.edu/~nr/noweb/}
%
%\bibitem[3]{syncweb} Yoann Padioleau,
%{\em Syncweb, literate programming meets unison}, 
%\url{http://padator.org/software/project-syncweb/readme.txt}
%
%
%\bibitem[4]{common-pad-manual} Yoann Padioleau,
%{\em Commons Pad OCaml Library}, 
%\url{http://padator.org/docs/Commons.pdf}
%
%
%\bibitem[5]{treemap-wikipedia} Wikipedia,
%{\em Treemapping}, 
%\url{http://en.wikipedia.org/wiki/Treemapping}
%
% SeeSoft and other code visualization 
%
%\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
