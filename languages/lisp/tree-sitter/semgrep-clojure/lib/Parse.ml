(* Generated by ocaml-tree-sitter. *)

(*
   Disable warning 42:
     "this use of Foo relies on type-directed disambiguation,
     it will not compile with OCaml 4.00 or earlier."
*)
[@@@warning "-42"]

(* Disable warnings against unused variables. *)
[@@@warning "-26-27-32"]

open Tree_sitter_bindings
open Tree_sitter_run

let debug = ref false

type mt = Run.matcher_token

external create_parser :
  unit -> Tree_sitter_API.ts_parser = "octs_create_parser_clojure"

let ts_parser = create_parser ()

let parse_source_string ?src_file contents =
  Tree_sitter_parsing.parse_source_string ?src_file ts_parser contents

let parse_source_file src_file =
  Tree_sitter_parsing.parse_source_file ts_parser src_file

let extras = [
]

let children_regexps : (string * Run.exp option) list = [
  "comment", None;
  "tok_pat_0a702c4_rep_choice_pat_0a702c4", None;
  "auto_res_mark", None;
  "char_lit", None;
  "tok_dquot_rep_pat_0d044a8_rep_bslash_pat_5058f1a_rep_pat_0d044a8_dquot",
  None;
  "ws", None;
  "nil_lit", None;
  "kwd_lit", None;
  "str_lit", None;
  "num_lit", None;
  "bool_lit", None;
  "regex_lit",
  Some (
    Seq [
      Token (Literal "#");
      Token (Name "tok_dquot_rep_pat_0d044a8_rep_bslash_pat_5058f1a_rep_pat_0d044a8_dquot");
    ];
  );
  "anon_fn_lit",
  Some (
    Seq [
      Repeat (
        Token (Name "metadata_lit");
      );
      Token (Literal "#");
      Token (Name "bare_list_lit");
    ];
  );
  "bare_list_lit",
  Some (
    Seq [
      Token (Literal "(");
      Repeat (
        Alt [|
          Token (Name "form");
          Token (Name "gap");
        |];
      );
      Token (Literal ")");
    ];
  );
  "bare_map_lit",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Alt [|
          Token (Name "form");
          Token (Name "gap");
        |];
      );
      Token (Literal "}");
    ];
  );
  "bare_set_lit",
  Some (
    Seq [
      Token (Literal "#");
      Token (Literal "{");
      Repeat (
        Alt [|
          Token (Name "form");
          Token (Name "gap");
        |];
      );
      Token (Literal "}");
    ];
  );
  "bare_vec_lit",
  Some (
    Seq [
      Token (Literal "[");
      Repeat (
        Alt [|
          Token (Name "form");
          Token (Name "gap");
        |];
      );
      Token (Literal "]");
    ];
  );
  "derefing_lit",
  Some (
    Seq [
      Repeat (
        Token (Name "metadata_lit");
      );
      Token (Literal "@");
      Repeat (
        Token (Name "gap");
      );
      Token (Name "form");
    ];
  );
  "dis_expr",
  Some (
    Seq [
      Token (Literal "#_");
      Repeat (
        Token (Name "gap");
      );
      Token (Name "form");
    ];
  );
  "evaling_lit",
  Some (
    Seq [
      Repeat (
        Token (Name "metadata_lit");
      );
      Token (Literal "#=");
      Repeat (
        Token (Name "gap");
      );
      Alt [|
        Token (Name "list_lit");
        Token (Name "read_cond_lit");
        Token (Name "sym_lit");
      |];
    ];
  );
  "form",
  Some (
    Alt [|
      Token (Name "num_lit");
      Token (Name "kwd_lit");
      Token (Name "str_lit");
      Token (Name "char_lit");
      Token (Name "nil_lit");
      Token (Name "bool_lit");
      Token (Name "sym_lit");
      Token (Name "list_lit");
      Token (Name "map_lit");
      Token (Name "vec_lit");
      Token (Name "set_lit");
      Token (Name "anon_fn_lit");
      Token (Name "regex_lit");
      Token (Name "read_cond_lit");
      Token (Name "splicing_read_cond_lit");
      Token (Name "ns_map_lit");
      Token (Name "var_quoting_lit");
      Token (Name "sym_val_lit");
      Token (Name "evaling_lit");
      Token (Name "tagged_or_ctor_lit");
      Token (Name "derefing_lit");
      Token (Name "quoting_lit");
      Token (Name "syn_quoting_lit");
      Token (Name "unquote_splicing_lit");
      Token (Name "unquoting_lit");
    |];
  );
  "gap",
  Some (
    Alt [|
      Token (Name "ws");
      Token (Name "comment");
      Token (Name "dis_expr");
    |];
  );
  "list_lit",
  Some (
    Seq [
      Repeat (
        Token (Name "metadata_lit");
      );
      Token (Name "bare_list_lit");
    ];
  );
  "map_lit",
  Some (
    Seq [
      Repeat (
        Token (Name "metadata_lit");
      );
      Token (Name "bare_map_lit");
    ];
  );
  "meta_lit",
  Some (
    Seq [
      Token (Literal "^");
      Repeat (
        Token (Name "gap");
      );
      Alt [|
        Token (Name "read_cond_lit");
        Token (Name "map_lit");
        Token (Name "str_lit");
        Token (Name "kwd_lit");
        Token (Name "sym_lit");
      |];
    ];
  );
  "metadata_lit",
  Some (
    Seq [
      Alt [|
        Token (Name "meta_lit");
        Token (Name "old_meta_lit");
      |];
      Opt (
        Repeat (
          Token (Name "gap");
        );
      );
    ];
  );
  "ns_map_lit",
  Some (
    Seq [
      Repeat (
        Token (Name "metadata_lit");
      );
      Token (Literal "#");
      Alt [|
        Token (Name "auto_res_mark");
        Token (Name "kwd_lit");
      |];
      Repeat (
        Token (Name "gap");
      );
      Token (Name "bare_map_lit");
    ];
  );
  "old_meta_lit",
  Some (
    Seq [
      Token (Literal "#^");
      Repeat (
        Token (Name "gap");
      );
      Alt [|
        Token (Name "read_cond_lit");
        Token (Name "map_lit");
        Token (Name "str_lit");
        Token (Name "kwd_lit");
        Token (Name "sym_lit");
      |];
    ];
  );
  "quoting_lit",
  Some (
    Seq [
      Repeat (
        Token (Name "metadata_lit");
      );
      Token (Literal "'");
      Repeat (
        Token (Name "gap");
      );
      Token (Name "form");
    ];
  );
  "read_cond_lit",
  Some (
    Seq [
      Repeat (
        Token (Name "metadata_lit");
      );
      Token (Literal "#?");
      Repeat (
        Token (Name "ws");
      );
      Token (Name "bare_list_lit");
    ];
  );
  "set_lit",
  Some (
    Seq [
      Repeat (
        Token (Name "metadata_lit");
      );
      Token (Name "bare_set_lit");
    ];
  );
  "splicing_read_cond_lit",
  Some (
    Seq [
      Repeat (
        Token (Name "metadata_lit");
      );
      Token (Literal "#?@");
      Repeat (
        Token (Name "ws");
      );
      Token (Name "bare_list_lit");
    ];
  );
  "sym_lit",
  Some (
    Seq [
      Repeat (
        Token (Name "metadata_lit");
      );
      Token (Name "tok_pat_0a702c4_rep_choice_pat_0a702c4");
    ];
  );
  "sym_val_lit",
  Some (
    Seq [
      Token (Literal "##");
      Repeat (
        Token (Name "gap");
      );
      Token (Name "sym_lit");
    ];
  );
  "syn_quoting_lit",
  Some (
    Seq [
      Repeat (
        Token (Name "metadata_lit");
      );
      Token (Literal "`");
      Repeat (
        Token (Name "gap");
      );
      Token (Name "form");
    ];
  );
  "tagged_or_ctor_lit",
  Some (
    Seq [
      Repeat (
        Token (Name "metadata_lit");
      );
      Token (Literal "#");
      Repeat (
        Token (Name "gap");
      );
      Token (Name "sym_lit");
      Repeat (
        Token (Name "gap");
      );
      Token (Name "form");
    ];
  );
  "unquote_splicing_lit",
  Some (
    Seq [
      Repeat (
        Token (Name "metadata_lit");
      );
      Token (Literal "~@");
      Repeat (
        Token (Name "gap");
      );
      Token (Name "form");
    ];
  );
  "unquoting_lit",
  Some (
    Seq [
      Repeat (
        Token (Name "metadata_lit");
      );
      Token (Literal "~");
      Repeat (
        Token (Name "gap");
      );
      Token (Name "form");
    ];
  );
  "var_quoting_lit",
  Some (
    Seq [
      Repeat (
        Token (Name "metadata_lit");
      );
      Token (Literal "#'");
      Repeat (
        Token (Name "gap");
      );
      Token (Name "form");
    ];
  );
  "vec_lit",
  Some (
    Seq [
      Repeat (
        Token (Name "metadata_lit");
      );
      Token (Name "bare_vec_lit");
    ];
  );
  "source",
  Some (
    Repeat (
      Alt [|
        Token (Name "form");
        Token (Name "gap");
      |];
    );
  );
]

let trans_comment ((kind, body) : mt) : CST.comment =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_tok_pat_0a702c4_rep_choice_pat_0a702c4 ((kind, body) : mt) : CST.tok_pat_0a702c4_rep_choice_pat_0a702c4 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_auto_res_mark ((kind, body) : mt) : CST.auto_res_mark =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_char_lit ((kind, body) : mt) : CST.char_lit =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_tok_dquot_rep_pat_0d044a8_rep_bslash_pat_5058f1a_rep_pat_0d044a8_dquot ((kind, body) : mt) : CST.tok_dquot_rep_pat_0d044a8_rep_bslash_pat_5058f1a_rep_pat_0d044a8_dquot =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_ws ((kind, body) : mt) : CST.ws =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_nil_lit ((kind, body) : mt) : CST.nil_lit =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_kwd_lit ((kind, body) : mt) : CST.kwd_lit =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_str_lit ((kind, body) : mt) : CST.str_lit =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_num_lit ((kind, body) : mt) : CST.num_lit =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_bool_lit ((kind, body) : mt) : CST.bool_lit =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_regex_lit ((kind, body) : mt) : CST.regex_lit =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_tok_dquot_rep_pat_0d044a8_rep_bslash_pat_5058f1a_rep_pat_0d044a8_dquot (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_anon_fn_lit ((kind, body) : mt) : CST.anon_fn_lit =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.repeat
              (fun v -> trans_metadata_lit (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_bare_list_lit (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_bare_list_lit ((kind, body) : mt) : CST.bare_list_lit =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Form (
                      trans_form (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Gap (
                      trans_gap (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_bare_map_lit ((kind, body) : mt) : CST.bare_map_lit =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Form (
                      trans_form (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Gap (
                      trans_gap (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_bare_set_lit ((kind, body) : mt) : CST.bare_set_lit =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Form (
                      trans_form (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Gap (
                      trans_gap (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_bare_vec_lit ((kind, body) : mt) : CST.bare_vec_lit =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Form (
                      trans_form (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Gap (
                      trans_gap (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_derefing_lit ((kind, body) : mt) : CST.derefing_lit =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.repeat
              (fun v -> trans_metadata_lit (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.repeat
              (fun v -> trans_gap (Run.matcher_token v))
              v2
            ,
            trans_form (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_dis_expr ((kind, body) : mt) : CST.dis_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_gap (Run.matcher_token v))
              v1
            ,
            trans_form (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_evaling_lit ((kind, body) : mt) : CST.evaling_lit =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.repeat
              (fun v -> trans_metadata_lit (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.repeat
              (fun v -> trans_gap (Run.matcher_token v))
              v2
            ,
            (match v3 with
            | Alt (0, v) ->
                `List_lit (
                  trans_list_lit (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Read_cond_lit (
                  trans_read_cond_lit (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Sym_lit (
                  trans_sym_lit (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_form ((kind, body) : mt) : CST.form =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Num_lit (
            trans_num_lit (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Kwd_lit (
            trans_kwd_lit (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Str_lit (
            trans_str_lit (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Char_lit (
            trans_char_lit (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Nil_lit (
            trans_nil_lit (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Bool_lit (
            trans_bool_lit (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Sym_lit (
            trans_sym_lit (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `List_lit (
            trans_list_lit (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Map_lit (
            trans_map_lit (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Vec_lit (
            trans_vec_lit (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Set_lit (
            trans_set_lit (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `Anon_fn_lit (
            trans_anon_fn_lit (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `Regex_lit (
            trans_regex_lit (Run.matcher_token v)
          )
      | Alt (13, v) ->
          `Read_cond_lit (
            trans_read_cond_lit (Run.matcher_token v)
          )
      | Alt (14, v) ->
          `Spli_read_cond_lit (
            trans_splicing_read_cond_lit (Run.matcher_token v)
          )
      | Alt (15, v) ->
          `Ns_map_lit (
            trans_ns_map_lit (Run.matcher_token v)
          )
      | Alt (16, v) ->
          `Var_quot_lit (
            trans_var_quoting_lit (Run.matcher_token v)
          )
      | Alt (17, v) ->
          `Sym_val_lit (
            trans_sym_val_lit (Run.matcher_token v)
          )
      | Alt (18, v) ->
          `Eval_lit (
            trans_evaling_lit (Run.matcher_token v)
          )
      | Alt (19, v) ->
          `Tagged_or_ctor_lit (
            trans_tagged_or_ctor_lit (Run.matcher_token v)
          )
      | Alt (20, v) ->
          `Dere_lit (
            trans_derefing_lit (Run.matcher_token v)
          )
      | Alt (21, v) ->
          `Quot_lit (
            trans_quoting_lit (Run.matcher_token v)
          )
      | Alt (22, v) ->
          `Syn_quot_lit (
            trans_syn_quoting_lit (Run.matcher_token v)
          )
      | Alt (23, v) ->
          `Unqu_spli_lit (
            trans_unquote_splicing_lit (Run.matcher_token v)
          )
      | Alt (24, v) ->
          `Unqu_lit (
            trans_unquoting_lit (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_gap ((kind, body) : mt) : CST.gap =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Ws (
            trans_ws (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Comm (
            trans_comment (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Dis_expr (
            trans_dis_expr (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_list_lit ((kind, body) : mt) : CST.list_lit =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.repeat
              (fun v -> trans_metadata_lit (Run.matcher_token v))
              v0
            ,
            trans_bare_list_lit (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_map_lit ((kind, body) : mt) : CST.map_lit =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.repeat
              (fun v -> trans_metadata_lit (Run.matcher_token v))
              v0
            ,
            trans_bare_map_lit (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_meta_lit ((kind, body) : mt) : CST.meta_lit =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_gap (Run.matcher_token v))
              v1
            ,
            (match v2 with
            | Alt (0, v) ->
                `Read_cond_lit (
                  trans_read_cond_lit (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Map_lit (
                  trans_map_lit (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Str_lit (
                  trans_str_lit (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Kwd_lit (
                  trans_kwd_lit (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `Sym_lit (
                  trans_sym_lit (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_metadata_lit ((kind, body) : mt) : CST.metadata_lit =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Meta_lit (
                  trans_meta_lit (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Old_meta_lit (
                  trans_old_meta_lit (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.opt
              (fun v ->
                Run.repeat
                  (fun v -> trans_gap (Run.matcher_token v))
                  v
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_ns_map_lit ((kind, body) : mt) : CST.ns_map_lit =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.repeat
              (fun v -> trans_metadata_lit (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Auto_res_mark (
                  trans_auto_res_mark (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Kwd_lit (
                  trans_kwd_lit (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.repeat
              (fun v -> trans_gap (Run.matcher_token v))
              v3
            ,
            trans_bare_map_lit (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_old_meta_lit ((kind, body) : mt) : CST.old_meta_lit =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_gap (Run.matcher_token v))
              v1
            ,
            (match v2 with
            | Alt (0, v) ->
                `Read_cond_lit (
                  trans_read_cond_lit (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Map_lit (
                  trans_map_lit (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Str_lit (
                  trans_str_lit (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Kwd_lit (
                  trans_kwd_lit (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `Sym_lit (
                  trans_sym_lit (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_quoting_lit ((kind, body) : mt) : CST.quoting_lit =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.repeat
              (fun v -> trans_metadata_lit (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.repeat
              (fun v -> trans_gap (Run.matcher_token v))
              v2
            ,
            trans_form (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_read_cond_lit ((kind, body) : mt) : CST.read_cond_lit =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.repeat
              (fun v -> trans_metadata_lit (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.repeat
              (fun v -> trans_ws (Run.matcher_token v))
              v2
            ,
            trans_bare_list_lit (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_set_lit ((kind, body) : mt) : CST.set_lit =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.repeat
              (fun v -> trans_metadata_lit (Run.matcher_token v))
              v0
            ,
            trans_bare_set_lit (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_splicing_read_cond_lit ((kind, body) : mt) : CST.splicing_read_cond_lit =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.repeat
              (fun v -> trans_metadata_lit (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.repeat
              (fun v -> trans_ws (Run.matcher_token v))
              v2
            ,
            trans_bare_list_lit (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_sym_lit ((kind, body) : mt) : CST.sym_lit =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.repeat
              (fun v -> trans_metadata_lit (Run.matcher_token v))
              v0
            ,
            trans_tok_pat_0a702c4_rep_choice_pat_0a702c4 (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_sym_val_lit ((kind, body) : mt) : CST.sym_val_lit =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_gap (Run.matcher_token v))
              v1
            ,
            trans_sym_lit (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_syn_quoting_lit ((kind, body) : mt) : CST.syn_quoting_lit =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.repeat
              (fun v -> trans_metadata_lit (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.repeat
              (fun v -> trans_gap (Run.matcher_token v))
              v2
            ,
            trans_form (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_tagged_or_ctor_lit ((kind, body) : mt) : CST.tagged_or_ctor_lit =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.repeat
              (fun v -> trans_metadata_lit (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.repeat
              (fun v -> trans_gap (Run.matcher_token v))
              v2
            ,
            trans_sym_lit (Run.matcher_token v3),
            Run.repeat
              (fun v -> trans_gap (Run.matcher_token v))
              v4
            ,
            trans_form (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_unquote_splicing_lit ((kind, body) : mt) : CST.unquote_splicing_lit =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.repeat
              (fun v -> trans_metadata_lit (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.repeat
              (fun v -> trans_gap (Run.matcher_token v))
              v2
            ,
            trans_form (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_unquoting_lit ((kind, body) : mt) : CST.unquoting_lit =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.repeat
              (fun v -> trans_metadata_lit (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.repeat
              (fun v -> trans_gap (Run.matcher_token v))
              v2
            ,
            trans_form (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_var_quoting_lit ((kind, body) : mt) : CST.var_quoting_lit =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.repeat
              (fun v -> trans_metadata_lit (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.repeat
              (fun v -> trans_gap (Run.matcher_token v))
              v2
            ,
            trans_form (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_vec_lit ((kind, body) : mt) : CST.vec_lit =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.repeat
              (fun v -> trans_metadata_lit (Run.matcher_token v))
              v0
            ,
            trans_bare_vec_lit (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_source ((kind, body) : mt) : CST.source =
  match body with
  | Children v ->
      Run.repeat
        (fun v ->
          (match v with
          | Alt (0, v) ->
              `Form (
                trans_form (Run.matcher_token v)
              )
          | Alt (1, v) ->
              `Gap (
                trans_gap (Run.matcher_token v)
              )
          | _ -> assert false
          )
        )
        v
  | Leaf _ -> assert false

(*
   Costly operation that translates a whole tree or subtree.

   The first pass translates it into a generic tree structure suitable
   to guess which node corresponds to each grammar rule.
   The second pass is a translation into a typed tree where each grammar
   node has its own type.

   This function is called:
   - once on the root of the program after removing extras
     (comments and other nodes that occur anywhere independently from
     the grammar);
   - once of each extra node, resulting in its own independent tree of type
     'extra'.
*)
let translate_tree src node trans_x =
  let matched_tree = Run.match_tree children_regexps src node in
  Option.map trans_x matched_tree


let translate_extra src (node : Tree_sitter_output_t.node) : CST.extra option =
  None

let translate_root src root_node =
  translate_tree src root_node trans_source

let parse_input_tree input_tree =
  let orig_root_node = Tree_sitter_parsing.root input_tree in
  let src = Tree_sitter_parsing.src input_tree in
  let errors = Run.extract_errors src orig_root_node in
  let opt_program, extras =
     Run.translate
       ~extras
       ~translate_root:(translate_root src)
       ~translate_extra:(translate_extra src)
       orig_root_node
  in
  Parsing_result.create src opt_program extras errors

let string ?src_file contents =
  let input_tree = parse_source_string ?src_file contents in
  parse_input_tree input_tree

let file src_file =
  let input_tree = parse_source_file src_file in
  parse_input_tree input_tree

